Существует 6 техник тест дизайна для Black Box метода. 
Озвучим их и вкратце обговорим в чём их смысл:

1. Техника эквивалетных классов.
{
    Правила данной техники тест-дизайна просты:
1) Определяем все классы эквивалентности:
2) Пишем минимум по 1-му тесту на каждый класс.
}

2. Техника граничных значений.
{
    Правила данной техники тест-дизайна 
1) Определяем все классы эквивалентности;
2) Определяем граничные значения классов эквивалентности;
3) Проводим до 3 тестов (граница, граница+1, граница-1).
}

3. Техника таблиц решений.

Вкратце:

{
    Данную технику применяют при наличии 2+ входных значений.
    Комбинации этих значений должны выдавать разные результаты.

    Простейший пример: тестирование авторизации на сайте логином и паролем.

    Здесь мы имеем целых 4 варианта развития событий:
    1) Логин и Пароль валидны - Авторизация;
    2) Логин валиден, Пароль нет - Ошибка;
    3) Пароль валиден, Логин нет - Ошибка;
    4) Логин и Пароль не валидны - Ошибка.

    При применении данной техники обычно рисуют таблицы, показывающие зависимость результата от 
    входных данных. Часто обходятся простейшей табличкой с "+" и "-".
}

4. Техника таблиц переходов и состояний:

- Вкратце
Порядок действий: 
    1: Составляем диаграмму состояний тестируемого объекта;
    2: Определяем триггеры, приводящие к смене состояния/ влияющие на объект
    3: Составляем диаграмму состояний/ триггеров;
    4: Комбинируем каждое состояние со всеми триггерами;
    5: Определяем 3 категории тестов: позитивные, негативные, невалидные;
    6: Последнюю категорию (невалидные) ОЧЕНЬ ВНИМАТЕЛЬНО отсеиваем.

Метод  не подходит для глубоких проверок - не даёт достаточно оснований признать фичу
полностью работоспособной.

- Подробно:
{
    Этот метод не стоит использовать как единственный инструмент проверки глубоких фич.
    Его не достаточно для вынесения решения о полной работоспособности фичи.

    Однако он хорош, так как может натолкнуть  на интересные идеи тест-кейсов и выстроить
    основную идею проверки работоспособности какого-то функционала.

    Здесь вся техника основана на наличии объекта тестирования, который может находиться в разных
    состояниях в зависимости от входных данных. 

    Также при использовании этой техники не стоит забывать, что могут существовать входные данные,
    которые ВЛИЯЮТ на объект тестирования, но НЕ ИЗМЕНЯЮТ его состояний. Об этом чуть ниже.

    Пример: Здание в игре - экономической стратегии.
    Пускай у объекта - постройки - есть 4 состояния:
    1) Постройки не существует на территории игрока;
    2) Постройка в процессе возведения;
    3) Постройка готова, но "не открыта" - надо направить в неё юнитов;
    4) Постройка функционирует.

    У этих 4-ёх состояний есть триггеры - действия, меняющие состояние объекта:
    1) Покупка постройки;
    2) Ожидание или (пускай это мобильная игра) возможность "проплатить" моментальную постройку;
    3) Внесение в постройку ресурсов (юнитов);

    ТАКЖЕ пускай постройку можно будет вращать или перемещать перед началом строительства.
    Тогда нам добавится ещё 2 триггера, которые ВЛИЯЮТ на объект, но не ИЗМЕНЯЮТ его:
    1) Перемещение:
    2) Поворот.

    Вроде бы теперь мы можем собрать таблицу из двух столбцов - состояния и триггеры.
    Всего 4 состояния и 6 триггеров.

    Каждому состоянию принадлежит 1 или несколько триггеров, меняющих (или нет) это состояние.

    # Ещё не всё - начинаем думать "а что если?"
    {
    НО здесь мы останавливаемся и задаёмся вопросом: а что если к состоянию применить иной триггер:
    например, попытаться переместить постройку, находящуюся на этапе возведения? Ведь теоретически
    такое желание у игрока вполне может появиться.
    }

    # Начинаем настоящее тестирование - КОМБИНИРУЕМ В ЛОБ - всё со всем
    {
        Берём каждое состояние и комбинируем его с каждым триггером. В нашем случае получаем
        4 таблицы (количество таблиц = количеству состояний объекта).
        
        Далее определяем 3 категории:
        1) Позитивные тесты - действие возможно. Например, мы можем ускорить постройку за донат.

        2) Негативные - действие невозможно выполнить. Например, нельзя купить ещё 1 здание,
        пока строится предыдущее.
        
        3) Невалидные тесты - действие не предусмотрено системой. Ведь мы не можем повернуть здание, 
        которого ещё не существует.

        Невалидные тесты отбрасываются, оставшийся набор проверок превращается в наш чек-лист.

        Перед признанием теста невалидным стоит всегда лишний раз задаться, действительно ли данная
        проверка невозможна - мало ли мы что-то упустили и на самом деле в игре есть механика 
        позволяющая, например, внести некоторые ресурсы в здание в момент его возвдения?
    }
}

5. Тестирование по сценариям использования.
{
    Сценарий использования - перечень действий с помощью которых пользователь взаимодействует 
    с приложением для достижения какой-то конкретной цели.

    Используется данная техника для поиска багов и логических дыр, которые сложно найти 
    тестируя индивидуальные модули и отдельные части приложения отдельно друг от друга.

    Перед тестированием любого ПО неплохой тактикой является опрос заказчика с целью 
    предоставления им хотя бы нескольких сценариев использования ПО. Желательно уточнить, какой из
    сценариев используется чаще всего. Отталкиваясь от этого можно составить тест кейсы 
    таким образом, чтобы все сценарии были покрыты и имели наибольший приоритет для покрытия их
    автотестами в первую очередь.

    Если такую информацию невозможно получить от заказчика - нужно провести самостоятельный анализ 
    ПО и выявить сценарии по которым, предположительно, зачастую будут действовать будущие
    пользователи тестируемой программы или приложения.
}

6. Попарное тестирование.
{
    Применяется при наличии множества ВЗАИМОСВЯЗАННЫХ входных данных и необходимости комбинировать
    множество вариантов использования этих данных.

    Ещё раз: используется эта техника только тогда, когда входные данные связаны друг с другом - 
    когда результат выполнения теста НАПРЯМУЮ зависит от того, какие КОМБИНАЦИИ входных значений
    будут заданы.

    Пример: форма с полями "Логин", "Пароль" и кнопкой "Войти".

    Каждое поле имеет 2 состояния: пустое и заполненное.
    Если результат работы формы не зависит от этих двух полей - нам будет достаточно воспользоваться
    техникой таблиц решений и провести 3 теста:

    1) Оба поля заполнены
    2) Заполнено поле "Логин"
    3) Заполнено поле "пароль"

    В данном случае взаимосвязь полей принесёт нам необходимость проверить ещё 1 вариант:
    4) Оба поля пусты.

    Ведь мы рассматривали работу каждого поля отдельно не задумываясь о том, что их комбинации
    могут сломать систему.

    Вроде бы всё просто. Но так только кажется.

    # Реальный пример использования техники попарного тестирования
    {
        Берём "нормальную" форму регистрации пользователя с 6 полями:
        E-Mail, никнейм, пароль, повтор пароля, чекбокс "Условия", капча.
        Состояние полей остаётся прежнее - заполненое и пустое.
        
        Количество тестов с таким количество полей возрастёт до 2^6 = 64.

        Это слишком много. отребуется много ресурсов, а результатом будет лишь проверка 
        одной формы регистрации пользователя.

        # Суть техники - комбинирование пар значений, а не каждого самостоятельного значения:
        {
            Используем технику попарного тестирования - БЕРЁМ КОМБИНАЦИИ ПАР каждых значений.
            Например:
            1: "E-Mail" + "никнейм" заполнены;
            2: "Пароль" совпадает с "Пароль ещё раз";
            3: "Пароль" не совпадает с "Пароль ещё раз";
            4: Чекбокс "Условия" не выбран, символы "Капчи" неверны.
            и т.д.

            Вручную делать данные операции не обязательно - есть вполне рабочие генераторы, 
            например https://pairwise.teremokgames.com/ 

            В итоге мы получим 14 тестов, которые будут проверять сразу несколько пар комбинаций:
            "E-mail" - "Никнейм", "Никнейм" - "Пароль", "Условия" - "Символы", "E-mail - Пароль" и т.д.

            Таким образом мы серьёзно сократим количество тестов, получив при этом неплохое или даже
            отличное тестовое покрытие формы.
        }
    }
}

6,5. Доменное тестирование. Всё новое - это хорошо забытое старое.
{
    Доменное тестирование предполагает некую комбинацию техник граничных значений и эквивалентных
    классов. То бишь это не новая техника, а переосмысление двух уже существующих.

    Доменное тестирование направлено на уменьшение количества тестов за счёт комбинирования 
    позитивных тестов. Так, если нам надо проверить 2 поля формы: "логин" и "пароль" - мы можем
    ввести валидные значения в оба поля сразу и не потерять в качестве.
    
    Но тут есть проблема: может сложиться ситуация, при которой невозможно локализовать поле, 
    которое вызывает ошибку. Так, зачастую, в формах авторизации часто пишут "Неверный логин /пароль".

    # Принцип доменного тестирования:
    {
        1: Делим входные значения на группы. Группы могут быть построены на любом факторе.

        2: Выявляем набор значений и выбираем наиболее показательных представителей каждой группы,
        обязательно включая в них пограничные значения.

        3: Комбинируем значения таким образом, чтобы отдельные параметры можно было бы протестировать
        одновременно.
    }
}