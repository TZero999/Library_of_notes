1. [ SSH команды: ]

1. ls - показывает содержимое каталога. С флагами позволяет отображать ещё и права доступа и т.д.
ls - Простая и удобная команда. Без дополнительных флагов просто отображает все ВИДИМЫЕ файлы
и каталоги в выбранной директории.

Флаги для команды ls:
{
- a
Отображает ВСЕ (включая скрытые) файлы и директории.

- l
Отображает все ВИДИМЫЕ файлы и выводит дополнительную ифнормацию о них:
владелец, размер, права доступа последнее время имзенения и т.д.
}

Вывод, к примеру, "ls -l 'JavaScript с нуля.pdf'" выглядит приблизительно следующим образом:
{
    -rw-rw-r-- 1 tzero tzero 14808635 апр  5 15:33 'JavaScript с нуля.pdf'

Здесь: 
- “-rw-rw-r--“
Показывает текущие права доступа.

Здесь могут быть 4 главные буквы на которые надо обратить внимание: r,w,x,d.
- d
Означает, что тип файла — это каталог. Стоит на первом месте или отсутствует. 
- x
Разрешение на выполнение файла или папки (это разрешение необходимо для входа в папку).
- w
Разрешение на запись файла или папки (редактирование, удаление и т.д.)
- r
Права на чтение. Вы можете читать файл, но не можете выполнять иные действия.

- 1
Число хард связи.
Хард связь - это дополнительное имя для существующего файла.

- tzero tzero
Показывает владельца файла и его группу.

- 14808635
Показывает размер файла в байтах.

- апр  5 15:33
Дата последнего изменения

- 'JavaScript с нуля.pdf'
Имя файла или папки
}

* cat - отобразить содержимое файла
- cat file1.txt
Отобразить содержимое файл 1

- cat file1.txt file2.txt file3.txt
Отобразить содержимое сразу 3 файлов

- cat file1.txt - file2.txt
Комбинирование вывода текста из файла и стандартного ввода

-  cat file1 file2 > file3
Запись содержимого файлов 1 и 2 в файл 3

Флаги для команды cat:
{
- cat -b
Нумеровать только непустые строки
- cat -E
Показывать символ $ в конце каждой строки
- cat -n
Нумеровать все строки
- cat -s 
Удалять пустые повторяющиеся строки
- cat -T 
Отображать табуляции в виде ^I
- cat -h 
Отобразить справку
- cat -v
Версия утилиты
}

* cp - копирование файлов и папок
2 варианта синтаксиса:
$ cp опции путь_к_файлу_источнику путь_к_файлу_назначения
Копирование файла в ту же директорию под другим именем

$ cp опции путь_к_файлу_источнику путь_к_директории_назначения
Копирование файла в другую директорию с сохранением имени

Параметры команды cp:
{
--attributes-only
Не копировать содержимое файла, а только флаги доступа и владельца;
- b, --backup
Создать резервную копию файла назначения если он существует;
--copy-contents
Копировать содержимое для специальных файлов (сокеты, файлы устройств);
- f, --force
Удалить файл назначения перед попыткой записи в него если он существует;
- i, --interactive 
Спрашивать, нужно ли перезаписывать существующие файлы;
- n, --no-clobber
Не перезаписывать существующие файлы;
- P, --no-dereference
Копировать сами символические ссылки, а не то на что они указывают;
- L, --dereference
Копировать не символические ссылки, а то, на что они указывают;
- l, --link
Создавать жесткие ссылки вместо копирования;
--preserve
Переносить указанные атрибуты с файла источника в файл назначения, возможные значения: mode, ownership, time‐stamps, context, links, xattr, all;
--no-preserve 
Не переносить указанные атрибуты;
--parents
Сохранять путь, указанный в файле источнике, в папке назначения;
- r, --recursive
Копировать папку Linux рекурсивно;
--reflink
Использовать Copy on Write если это поддерживается файловой системой;
- s, --symbolic-link
Не выполнять копирование файлов в Linux, а создавать символические ссылки;
- S, --suffix
Указать суффикс для резервных копий файлов;
--sparse 
Настройка работы с разреженными файлами;
- t, --target-directory
Считать файл-назначения директорией и копировать файл-источник или директорию-источник в эту директорию с оригинальным именем;
- T, --no-target-directory
Считать директорию назначения файлом или директорией для записи данных. Если в качестве источника выбран файл, то он будет скопирован с новым именем. Если директория, то её содержимое будет скопировано в директорию назначения;
- u, --upgrade
Скопировать файл, только если он был изменён;
- x, --one-file-system
Рекурсивное копирование не должно выходить за пределы этой файловой системы;
- v, --verbose
Максимально подробный вывод.
- p
Сохранять владельца, временные метки и флаги доступа при копировании,
аналогично --preserve=mode,ownership,timestamps;
- d
Копировать символические и жесткие ссылки именно как ссылки,
аналогично --no-dereference --preserve=links;
- a
Режим резервного копирования, при котором сохраняются все атрибуты, ссылки,
и выполняется резервное копирование папок.
Аналогично --recursive --preserve=all, --no-dereference;
}

* find - поиск файлов и папок
Синтаксис: 
find [папка] [параметры] критерий шаблон [действие]
"Папка" - каталог в котором будем искать
"Параметры" - дополнительные параметры, например, глубина поиска, и т д
"Критерий" - по какому критерию будем искать: имя, дата создания, права, владелец и т д.
"Шаблон" - непосредственно значение по которому будем отбирать файлы.

Параметры команды find:
{
- P
Никогда не открывать символические ссылки.
- L
Получает информацию о файлах по символическим ссылкам.
Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
- maxdepth
Максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
- depth
Искать сначала в текущем каталоге, а потом в подкаталогах.
- mount
Искать файлы только в этой файловой системе.
- version
Показать версию утилиты find.
- print
Выводить полные имена файлов.
- type f
Искать только файлы.
- type d
Поиск папки в Linux.
}

Критерии команды find:
{
- name
Поиск файлов по имени.
- perm
Поиск файлов в Linux по режиму доступа.
- user
Поиск файлов по владельцу.
- group
Поиск по группе.
- mtime
Поиск по времени модификации файла.
- atime
Поиск файлов по дате последнего чтения.
- nogroup
Поиск файлов, не принадлежащих ни одной группе.
- nouser
Поиск файлов без владельцев.
- newer
Найти файлы новее чем указанный.
- size
Поиск файлов в Linux по их размеру.
}

Примеры на https://losst.pro/komanda-find-v-linux?pplrurl=1

* cd - сменить текущий каталог
Синтаксис:
cd [OPTIONS] [Path/to/Directory]

Пример:
cd /home/tzero/CodeceptJS

Параметры CD (всего 3):
{
- L
Переходить по символическим ссылкам. CD без параметров всегда работает в режиме "L".
- P
Не переходить по символическим ссылкам. Если осуществляется переход на символическую ссылку 
(при указанном параметре -P), которая указывает на директорию, то в результате команда cd изменит
текущую рабочую директорию на директорию, указанную в качестве параметра (то есть ссылка будет разыменована).
- P -e
Позволяет выйти с ошибкой, если указанная директория не существует.
}

Более подробная информация про команду "CD" и её параметры: https://pingvinus.ru/note/cmd-cd

* pwd - отобразить текущую директорию
Синтаксис:
pwd [опции]

Простейшая команда, позволяющая вывести в терминал путь к директории, в которой вы сейчас
находитесь. Для терминала Linux стандартная директория - это домашний каталог пользователя.

При этом каждая запущенная программа считает текущей папкой именно ту папку, из которой
эта программа была запущена.

Опции команды pwd:
{
- L, --logical
брать директорию из переменной окружения, даже если она содержит символические ссылки;
- P
Как и в случае с CD позволяет отбрасывать все символические ссылки;
--help
Позволяет отобразить справку по утилите;
--version
Позволяет отобразить версию утилиты.
}

* mkdir - создать новую папку
Синтаксис:
$ mkdir [опции] [Директория_1 Директория_2 Директория_3]

Команда используется для создания новых каталогов. Расшифровывается как 
"MaKe DIRectory". Позволяет с помощью терминала создать папку с определённым именем внутри
текущего каталога.

Можно создать сразу несколько директорий, указав их имена через пробел.
Можно создать ЦЕПОЧКУ ДИРЕКТОРИЙ, но для этого необходимо УКАЗАТЬ ФЛАГ "-p".

Опции для mkdir:
{
- m=MODE или --mode=MODE
Позволяет сходу установить права доступа для создаваемой директории.
Синтаксис MODE такой же, как у chmod.

- p или --parents
Позволяет создать все директории, указанные внутри пути.
То бишь позволяет создать все директории, указанные в пути.
Если какая-то из директорий уже существует - уведомлений об этом не отображается.

- v или --verbose
Выводить некий отчёт по каждой созданной директории, например 
"mkdir: создан каталог 'NewFolder'"

- Z
Установить контекст SELinux для создаваемой директории по умолчанию.

--context[=CTX]
Установить контекст SELinux для создаваемой директории в значение CTX
}

Пример использования mkdir:
$ mkdir NewFolder
Создаст в текущем каталоге папку "NewFolder".

* touch - создание файла с указанным расширением
Синтаксис:
$ touch [опции] [файл1.расширение файл2.расширение файл3.расширение]

Причём расширение можно указать совершенно любым или не указывать его вовсе.
Создать можно несколько файлов за раз, указывая их имена и расширения через пробел.

Опции команды touch:
{
- a
Позволяет изменить ТОЛЬКО время доступа к указанному файлу.

- m
Позволяет изменить ТОЛЬКО время модификации файла.

- c
Позволяет обновить временные метки у существующего файла.
Если указанного файла не существует - команда будет проигнорирована
    
- r file1 file2 или --reference= file1 file2
Позволяет указать время доступа и модификации другого файла в качестве времени
доступа и модификации указанного файла.

- t YYMMDDhhmm.ss
Позволяет установить время последнего доступа и модификации файла на указанную.

- d 'day month year hh:mm' или --date='day month year hh:mm'
Позволяет изменить время и дату доступа и модификации, задав её в виде строки.

- h sym-link1
Позволяет изменит время изменения и доступа символической ссылки.
}

* rm - удаление указанного файла или каталога
Синтаксис:
$ rm [опции] [файл1 файл2 файл3]

Позволяет удалить указанные файлы или каталог. Для удаления каталога необходимо 
использовать флаг "-r". Для удаления нескольких файлов их названия надо записать
через пробел.

Пример:
$ rm NewFile
Удалит файл NewFile в текущем каталоге.

$ rm -r NewDirectory
Удалит каталог NewDirectory, располагающийся в текущем каталоге.

Параметры команды "rm":
{
- f или --force
Игнорировать несуществующие файлы и аргументы, никогда не выдавать запросы на подтверждение удаления.

- i
Выводить запрос на подтверждение удаления для каждого файла.

- I
Вывести 1 запрос на подтверждение удаления всех файлов, если удаляется >3 файлов или 
используется флаг "-r". Более щадящая версия флага "-i"

- --interactive[=КОГДА]
Вместо КОГДА можно использовать:
    "never"  — никогда не выдавать запросы на подтверждение удаления.
    "once"   — выводить запрос один раз (аналог опции -I).
    "always" — выводить запрос всегда (аналог опции -i).
По умолчанию используется "always"

- --one-file-system
При наличии флага "-r" не удалять директории, находящиеся на других файловых системах.

- --no-preserve-root
Позволяет удалить корневой раздел.

- --preserve-root
Запрещает удалять корневой раздел. такое поведение используется по умолчанию.

- r или -R или --recursive
Удаление директорий и их содержимого. Принято называть "Рекурсивным удалением"

- d или --dir
Удалить пустые директории.

- v или --verbose
Выводит информацию о каждом удаляемом файле.
}

Примечание: удаляем файл с названием, начинающимся с "-":
{
$ rm -- -myfile
или
$ rm ./-myfile
}
Подробнее на: https://pingvinus.ru/note/cmd-rm

* mv - перемещение/переименование файлов и папок
Синтаксис:
$ mv [опции] [исходные_файлы] [место_назначения]

"Исходным файлом" могут быть один файл, несколько файлов, один каталог или сразу несколько каталогов.

"Место назначения" -  это название директории, в которую мы перемещаем исходные файлы или директории.
Или же это новое название файла или директории, если выполняется переименование. 
То есть это либо директория, либо новое название файла или директории.

Параметры команды "mv":
{
- b или --backup или --backup=МЕТОД
Позволяет создать резервную копию существующих файлов, которые будут перезаписаны или удалены.
Имя для резервной копии создаётся по определенным правилам. Правила можно контролтровать. Для 
этого используется опция "--backup=МЕТОД" В качестве значения МЕТОД можно указать:

"none" или "off"     — не делать резервных копий, даже если включена опция --backup
"numbered" или "t"   — имена резервных копий получат числовые индексы: myfile.txt~2~ и т.д.
"simple" или "never" — делать обычные резервные копии с именами по типу: myfile.txt~.
"existing" или "nil" — если в директории уже есть резервные копии с числовыми индексами - использовать числовые
индексы для новых резервных копий. Иначе использовать метод simple.

- f или --force
Не спрашивать разрешения пользователя для перезаписи файлов.

- i или --interactive
Спрашивать разрешение пользователя для перезаписи файлов.

- n или --no-clobber
Не позволяет перезаписывать существующие файлы.

- --strip-trailing-slashes
Удалить завершающий символ "слеш /" (если он там есть) из имени файла-источника.

- s или --suffix=СУФФИКС
Работает только при использовании опции "--backup". 
Позволяет изменить символ суффикса, который добавляется к именам резервных копий.
По умолчанию СУФФИКС равен значку "тильды ~"

- t или --target-directory=ДИРЕКТОРИЯ
Переместить все исходные файлы в директорию, которая указана в аргументе опции.

- u или --update
Перемещать только если исходный файл новее, чем файл назначения/ файл-назначения отсутствует.

- v или --verbose
Выводить информацию о каждом файле, который обрабатывает команда mv.

- z или --context
Установить контекст (метки) SELinux для файлов назначения в значение по умолчанию.
}

* [ Другие полезные команды Linux: ]

1. echo - добавление в файл - доработать
2. chown - изменить владельца файла или папки
Синтаксис: chown [владелец/группа владельца] [имя файла/каталога]

К примеру, если у нас есть файл “demo.txt” и мы хотим изменить владельца
на “jerry” и группу владельца на “clients”, нам необходима эта команда:
{
    chown jerry:clients demo.txt
}

Если хотим сменить только владельца и, например, не файла а папки:
{
    chown tzero Docker
}

3. chmod - изменить права доступа к файлу или папке
Перед использованием данной команды первым делом стоит проверить права доступа
к интересующим файлам командой "ls -l".

Эта команда позволяет изменить права доступа к файлу или папке.

Делается это путём складывания цифр, представляющих собой каждое из "прав":
r (чтение) – 4
w (запись) – 2
x (выполнение) – 1

Прописывается 3 номера. Каждый номер в этой команде представляет собой
права для одного из типов пользователей:
1-ый - это Владелец,
2-ой - это Группа,
3-ий - это "Другие".

Так, следующая команда даст все права всем типам пользователей (владелец, группа и другие):
{
    chmod 777 file2.txt
}

- Список самых распространённых прав доступа для файлов:
{
    -rw——- 	    600 	Владелец может читать и записывать файл.
    -rw-r–r– 	644 	Владелец может читать и записывать файл, группа и другие могут только читать.
    -rw-rw-rw- 	666 	Владелец, группа и другие могут читать и записывать.
    -rwx—— 	    700 	Владелец может читать, записывать и выполнять, группа и другие не
                        имеют никаких прав доступа.
    -rwx–x–x 	711 	Владелец может читать, записывать и выполнять, группа и другие
                        могут только выполнять.
    -rwxr-xr-x 	755 	Владелец может читать, записывать и выполнять, группа и другие 
                        могут читать и выполнять.
    -rwxrwxrwx 	777 	Все типы пользователей могут читать, записывать и выполнять.
}

- Список самых распространённых прав доступа для каталогов:
{
    drwx—— 	700 	Только владелец может читать и записывать в этом каталоге.
    drwxr-xr-x 	755 	Владелец, группа и другие могут читать каталог, но только владелец
                        может изменять содержимое каталога.
}

* СИМВОЛИЧЕСКИЕ и НЕСИМВОЛИЧЕСКИЕ ссылки. Что это?
Ссылки в Linux бывают "символические" и "жёсткие".
Ссылки чем-то похожи на ярлыки в Windows. Ссылка указывает на какой-либо файл или директорию.
Эту ссылку можно разместить в другой директории. Обращаясь к ссылке вы будете обращаться к 
настоящему файлу, но как будто через "посредника".

- Символические
Символическая ссылка - специальный файл, являющийся ссылкой на другой файл/ каталог.
Порой такие ссылки называют "символьными", "мягкими" и "сим-ссылками".

Символическая ссылка НЕ СОДЕРЖИТ в себе копию файла, на которую указывает. Она - лишь 
указатель. Однако при всём этом символьная ссылка обладает своими собственными правами
на доступ.

По аналогии с Windows ссылки - это ярлыки. Можно создать много ссылок на 1 файл, но они 
будут носить разное имя и иметь разные права доступа.

Удаление символической ссылки не удаляет файл, на который она ссылается.
Если удалить файл, на который ссылкается ссылка - ссылка не обновится автоматически.

- Несимволические (жёсткие)
Жёсткие ссылки - это "синоним" существующего файла. При создании жёсткой ссылки копии файла
тоже не создаётся.

Жёсткие ссылки в файловой системе отображаются, как ещё один файл. Создавая жёсткую ссылку
в одном каталоге с целевым для неё файлом будет требоваться указать разные имена файлов.

Жёсткие ссылки на файл обязана находиться в той же файловой системе, что и другие 
жёсткие ссылки на этот файл.

В Linux все файлы имеют свой id, называемый "inode". Это число, которое однозначно 
идентифицирует конкретный файл в файловой системе. Так вот У ЖЁСТКОЙ ССЫЛКИ и ЕЁ 
ЦЕЛЕВОГО ФАЙЛА эти самые идентификаторы "inode" ОДИНАКОВЫ.
Потому жёсткая ссылка имеет ТАКИЕ ЖЕ ПРАВА ДОСТУПА, ВЛАДЕЛЬЦА и даже ДАТУ 
ПОСЛЕДНЕГО ИЗМЕНЕНИЯ, как и ЦЕЛЕВОЙ ФАЙЛ.

Нельзя создать жёсткую ссылку для директории, ТОЛЬКО ДЛЯ ФАЙЛА.

Жёсткие ссылки постепенно устаревают и используются редко.

- Пример:
$ pwd 
/home/tzero/VirtualBox VMs

$ pwd -P
/storage/VirtualBox VMs