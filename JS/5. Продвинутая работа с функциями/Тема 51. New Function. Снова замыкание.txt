Существует ещё один способ объявить функцию.
Он крайне редко используется, но порой без него не обойтись.

- Синтаксис:
let func = new Function([arg1, arg2, ...argN], functionBody);

Функцию можно создать с заранее заданными параметрами (arg1. arg2 и т.д.) и телом (functionBody).

Пример:
let sum = new Function ('a', 'b', 'return a+b');
alert( sum(1,2) );

А вот функции без аргументов достаточно только указать тело:
let sayHi = new Function(' alert("Hello!") ');
sayHi(); //# Hello!

Главное отличие от других способов объявления функции, рассмотренных ранее, в том, что функция создаётся "на лету".

Все предыдущие объявления требовали от нас писать объявление функции в скрипте, но "new Function" позволяет быстро преобразовать
любую строку в функцию с сервера и затем выполнить её:

Пример:
let str = ... код, полученный с сервера динамически ...
let func = new Function(str);
func();

Используется всё это в крайне специфических случаях, когда, например, нам приходит код с сервера для
динамической компиляции функции из шаблона в сложных веб-приложениях.

- И снова ЗАМЫКАНИЕ, немного о кодах, приходящих с сервера и о минификаторах
Вспоминаем замыкание и уточняем, что же в случае с синтаксисом "new Function" отличается.

Обычно функция запоминает место своего создания в свойстве [[Environment]].
Это - ссылка на внешнее (относительно функции) лексическое окружение, в котором она создана (см. тему 47).

но если мы создаём функцию через синтаксис "new Function", в её [[Environment]] записывается ссылка не на внешнее лексическое окружение,
в котором она была создана, а на глобальное. Следовательно, такая функция имеет доступ только к глобальным переменным.

Пример:
function getFunc() {
    let value = "test";
    let func = new Function('alert(value)');
    return func;
  }
getFunc()(); //# Должны были бы получить "test", а получили ошибку: value не определено

Если переписать эту функцию и заменить строку "let func = new Function('alert(value)')" на "let func = function() { alert(value); }" получим наш "test".
Эта особенность синтаксиса "new Function" выглядит странно, но на практике часто оказывается полезной.

Предположим, что из строки нам надо сделать функцию, но код функции нам пока неизвестен. Обычные функции мы использовать не сможем.
Такое может произойти, если код мы должны получать от сервера или с другого ресурса. Так, код будет определён только в процессе выполнения.

Причём наша новая функция должна будет взаимодейстовать с основным скриптом.

Проблема будет заключаться в том, что перед отправкой JS-кода на реальные проекты код сжимается с помощью МИНИФИКАТОРА.
Минификатор - специальная программа. Она удаляет комментарии, лишние пробелы, а локальные переменные (что для нас сейчас важнее всего) дают с 
укороченными вариантами имён.

Так, если в функции объявляется переменная let userName, то минификатор изменит её, например, на let a. Может изменить на любую другую свободную букву.
Делает минификатор это повсюду, заменяя каждое упоминание имени.

Минификаторы умны, они не просто осуществляют поиск-замену значения - они анализируют структуру кода, потому ничего не ломают.

Если бы new Function имела бы доступ к внешним переменным - минификаторы могли бы вызвать проблему.

К тому же такой код был бы архитектурно хуже и более подвержен ошибкам.
Чтобы передать что-то в функцию, которую создали через new Function, можно использовать её аргументы.

- ИТОГО
Синтаксис:
let func = new Function ([arg1, arg2, ...argN], functionBody);

По историческим причинам аргументы также могут быть объявлены в одной строке.
Т.О. эти 3 объявления ниже идентичны:
new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке

Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое окружение, а не на родительское.
Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что порой это страхует нас от ошибок.
Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.

