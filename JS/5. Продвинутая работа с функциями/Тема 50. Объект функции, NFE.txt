В JS функции имеют тип "Object".

Т.О. Функция = объект, который выполняет какое-то действие.
Исходя из этого функции можно не только вызывать, но и использовать как объекты: добавлять/ удалять свойства, передавать их по ссылке и т.д.

- Свойство NAME
Имя функции доступно нам как свойство "name":

function sayHi() {
    alert("Hi");
  };
alert(sayHi.name); // sayHi

Польза, казалось бы, мизерная, но свойство "name" работает и тогда, когда функция создаётся без имени и тут же присваивается:
    let sayHi = function() {
    alert("Hi");
  };
alert(sayHi.name); // sayHi (есть имя!)

Это - "контекстное имя". Если функция имени не имеет - JS пытается определить его из контекста.
Так же имена имеют и методы объекта:

let user = {
    sayHi() {
      // ...
    },
    sayBye: function() {
      // ...
    }
  }
alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye

Если определить имя невозможно - name будет иметь пустое значение. 
Пример:

let arr = [function() {}]; //# функция объявлена внутри массива
alert( arr[0].name ); // < > //# Отсутствует возможность определить имя - поэтому его и нет.

- Свойство LENGTH
Свойство "length" содержит количество параметров функции в её объявлении.

Пример:
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2 - остаточные параметры не считаются (тема 46)!

Используется данное свойство для "интроспекций" в функциях, работающих с другими функциями - запроса типа и структуры объекта во время выполнения кода.

Пример:
function ask(question, ...handlers) {
    let isYes = confirm(question);
  
    for(let handler of handlers) {
      if (handler.length == 0) {
        if (isYes) handler(); // для положительных ответов вызываются оба типа обработчиков
      } else {
        handler(isYes); // для отрицательных - только второго типа
      }
    }
}
ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));

Когда пользователь отвечает на вопрос, функция вызывает обработчики.

Мы можем передать два типа обработчиков:
* Функцию без аргументов, которая будет вызываться только в случае положительного ответа.
* Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.

Чтобы вызвать обработчик handler правильно - проверяем свойство handler.length.

Идея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов.
Вместе с тем мы имеем возможность передавать универсальные обработчики.

- ПОЛЬЗОВАТЕЛЬСКИЕ СВОЙСТВА
Мы имеем возможность добавлять свои пользовательские свойства.

Добавим свойство "counter" - оно будет отслеживать количество вызовов функции:

function sayHi() {
    alert("Hi");

    sayHi.counter++;
    }
 sayHi.counter = 0; //# Начальное значение счётчика
 sayHi(); //# Hi
 sayHi(); //# Hi
alert( `Вызвана ${sayHi.counter} раза` ); //# Вызвана 2 раза

- СВОЙСТВА ВМЕСТО ЗАМЫКАНИЙ
Иногда СВОЙСТВА ФУНКЦИИ можно использовать вместо ЗАМЫКАНИЙ (тема 47).

Рассмотрим функцию-счётчик из темы замыканий, а затем перепишем её используя пользовательское свойство:

1) Старый вариант с ЗАМЫКАНИЕМ:
function makeCounter() {
    let count = 0;
    return function() {
        return count++;
    };
}
let counter = makeCounter();
alert( counter() );//# 0
alert( counter() );//# 1
alert( counter() );//# 2

2) Новый вариант со СВОЙСТВОМ:
function makeCounter() {
    function counter() { //# Вместо let count = 0.
    return counter.count++;
    };
 counter.count = 0;
 return counter;
}
let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1

Теперь свойство "count" хранится у нас прямо в функции, а не в её внешнем лексическом окружении.

Лучше использовать свойства или замыкания?
Основное отличие в том, что если значение "count" живёт во внешней переменной - оно не доступно для внешнего кода.
Изменить его смогут только вложенные функции. А вот если мы присвоили его как свойство функции - его значение спокойно можно изменить извне:

function makeCounter() {
  ... {...} 
}
 let counter = makeCounter();
 counter.count = 10;
alert( counter() ); // 10

Поэтомы выбор реализации зависит от целей.

- СВОЙСТВО != ПЕРЕМЕННАЯ!
Свойство функции, назначенное выше как sayHi.counter = 0, НЕ ОБЪЯВЛЯЕТ ЛОКАЛЬНУЮ ПЕРЕМЕННУЮ counter.
Другими словами свойство "counter" и переменная "let counter" - две независимые вещи.

Мы можем использовать функцию как объект и хранить в ней свойства, но свойства не влияют на её выполнение.
Переменные - это не свойства и наоборот. Это - два параллельных мира.

- NAMED FUNCTION EXPRESSION
NFE - это термин для Function Expression, у которого есть имя.

Объявляем Function Expression:
let sayHi = function(who) {
    alert(`Hello, ${who}`);
};

Имени сейчас у него нет. Поэтому присвоим ему имя:
let sayHi = function func(who) {
    alert(`Hello, ${who}`);
};

Зачем это нужно?
Функция продолжает задаваться, как function expression. Добавление "func" после function не превращает её объявление в function declaration,
ведь оно всё ещё является частью выражения присваивания.

Таким образом, добавление такого имени, как минимум, ничего не ломает.
Функция всё ещё доступна как sayHi().
let sayHi = function func(who) {
    alert(`Hello, ${who}`);
    };
sayHi("John"); //# Hello, John

- Тогда зачем давать имена функциям, объявленным через Function Expression?
Есть 2 особенности, ради которых даётся имя:
1) Оно позволяет ссылаться на себя же;
2) Оно не доступно за пределами функции.

Пример, когда sayHi вызывает себя же с "Guest", при вызове функции без параметра:
let sayHi = function func(who) {
    if (who) {
      alert(`Hello, ${who}`);
    } else {
      func("Guest"); //# использует func, чтобы снова вызвать себя же
    }
};
sayHi(); // Hello, Guest
func(); //# Ошибка, func не определена (т.к. такая ссылка недоступна вне функции)

По идее можно было бы не использовать это имя, а просто использовать sayHi для вложенного вызова:
let sayHi = function(who) {
    if (who) {
      alert(`Hello, ${who}`);
    } else {
      sayHi("Guest");
    }
};
sayHi(); //# Hello, Guest

Но есть у этого кода проблема:
Функция может быть переприсвоена другой переменной, а значение переменной sayHi может быть изменено.
Тогда код начнёт выдавать ошибки:

let sayHi = function(who) {
    if (who) {
      alert(`Hello, ${who}`);
    } else {
      sayHi("Guest"); // Ошибка: sayHi не является функцией
    }
};
sayHi(); //# Hello, Guest 

let welcome = sayHi;
sayHi = null;
welcome(); //# Ошибка. Функция существует, а вот вложенный вызов sayHi не работает!

А вот при наличии имени у функции и ссылке на него внутри блока кода else - всё бы работало.

Это происходит из-за того, что локальная переменная sayHi отсутствует, функция берёт sayHi из внешнего лексического окружения. На момент вызова функции
внешняя sayHi равна null.

С именем функции всё будет работать, т.к. имя - локальное и находится внутри функции.
Теперь оно берётся не снаружи, да и вовсе недоступно отттуда.
Теперь мы можем быть уверены, что с помощью имени функции при её вызове она всегда будет ссылаться на текущую функцию.

* Это НЕ СРАБОТАЕТ с FUNCTION DECLARATION!
Трюк с "внутренним именем", который описан выше, не будет работать для Function Declaration. Для способа Function Declaration даже 
не предусмотрена возможность давать функции "внутреннее имя".

Поэтому если нам нужно надёжное "внутреннее имя" функции, стоит переписать Function Declaration на Named Function Expression.

- ИТОГО
Функции - это объекты.

У них есть 2 свойства "по умолчанию":
1) name - имя функции. Если его нет - JavaScript пытается "предугадать" его из контекста.
2) length - количество аргументов функции. Остаточные параметры (...args) - не считаются.

Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя - её называют "Named Function Expression - NFE".
Имя такой функции может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.д.

Также функции могут содержать пользовательские дополнительные свойства.
Многие известные библиотеки JS искускно используют эту возможность.

Так, они создают "основную" функцию и добавляют в неё множество "дополнительных функций". Так, бибилотека jQuery создаёт функцию с именем "$".
Библиотека lodash создаёт "_", а потом добавляет в неё "_.clone", "_.keyBy" и другие свойства.

Так они меньше засоряют глобальное пространство, так как одна библиотека предоставляет одну глобальную переменную и уменьшают тем самым
вероятность конфликта имён.

Поэтому функция не просто может делать что-то сама по себе, но также и предоставлять полезную функциональность через свои свойства.

