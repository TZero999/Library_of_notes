Существуют команды, позволяющие вызывать функцию не в данный момент, а позже, через заданный интервал времени.
Это - "планирование вызова".

Существует 2 метода планирования вызова:
1) setTimeout - вызывает функцию 1 (ОДИН) раз через определённый интервал времени.
2) setInterval - вызывает функцию РЕГУЛЯРНО, повтор происходит через определённый интервал времени.

Эти методы - НЕ часть спецификации JS, но большинство сред выполнение поддерживают возможность планирования вызова.

- setTimeout

Синтаксис:
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

func | code - сама функция или строка кода. Хотя использовать строку не рекомендуется.
delay - задержка перед запуском (в мс: 1000мс = 1с). По умолчанию 0.
arg1, arg2... - аргументы, передаваемые в функцию.

Пример:
function sayHi(phrase, who) {
    alert( phrase + ', ' + who + '!');
    }
setTimeout(sayHi, 1000, "Привет", "Джон"); //# Привет, Джон

- Строки кода вместо функций:
Если передаёт в метод строку - JS сам создаст из неё функцию.
Но если необходимо передать строку лучше самому сделать из неё функцию. Вот пример:
Вместо setTimeout('alert('Привет')', 1000);
Делаем setTimeout(() => alert('Привет'), 1000);

- () после функции не используются!
Ошибка начинающих разработчиков: setTimeout(sayHi(), 1000); - здесь ошибка.
setTimeout ожидает ссылку на функцию. Здесь же sayHi() запускает выполнение функции. Результат отправляется в setTimeout.
Результат sayHi в нашем случае - undefined, ведь функция ничего не возвращает. Поэтому планирование не сработает. 
К слову, return тоже может не помочь.

Так, в примере выше вместо "Привет, Джон!" получим "undefined, undefined!"

- Отмена планирования через clearTimeout
Вызов setTimeout возвращает "Идентификатор таймера" TimerId. Его можно использовать и для отмены дальнейшего выполнения.

Синтаксис:
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
clearTimeout(timerId);

Пример отмены запланированного вызова:
    let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
    alert(timerId); //# идентификатор таймера

    clearTimeout(timerId);
alert(timerId); //# тот же идентификатор (не принимает значение null после отмены)

Кстати, разные среды выполнения возвращают в качестве "timerId" разные значения.
Браузеры часто возвращают число. Node.js возвращает объект таймера и т.д.
Это происходит из-за того, что единой спецификации на эти методы нет.

- setInterval
Синтаксис такой же, как и у setTimeout:
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);

Единственное отличие метода только в том, что функция будет вызываться постоянно через указанный интервал времени.

Чтобы остановить выполнение функции необходимо вызвать clearInterval(timerId).

Пример:
let timerId = setInterval(() => alert('tick'), 1000); //# повторяем сообщение с интервалом в 1 секунду
setTimeout(() => { clearInterval(timerId); alert('stop');}, 5000); //# Останавливаем вывод через 5 секунд

*Во время показа "alert" время тоже идёт.
В большинстве браузеров внутренний счётчик продолжает тикать во время показа alert/ confirm/ prompt.
По итогу в примере выше интервал времени между сообщениями alert будет короче, чем 2 секунды.
Если тиков должно быть 5 - лучше установить таймер приблизительно на 5010 мс.

- Вложенный setTimeout
Есть 2 способа запускать функцию регулярно:
1) setInterval
2) Вложенный setTimeout 

Пример:
let timerId = setTimeout(function tick() {
    alert('tick');
    timerId = setTimeout(tick, 2000); //# *. Вместо let timerId = setInterval( () => alert('tick'), 2000 );
}, 2000);

Метод setTimeout выше планирует следующий вызов прямо после окончания текущего (*).

Вложенный setTimeout – более гибкий метод, чем setInterval.
С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.

Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд,
но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд… Вот псевдокод:

let delay = 5000;

let timerId = setTimeout(function request() {
    
    /* ...отправляем запрос... */

    if (ошибка запроса из-за перегрузки сервера) {  //# увеличить интервал для следующего запроса
    delay *= 2;
}
timerId = setTimeout(request, delay);
}, delay);

А если функции ресурсоёмкие и требуют много времени - мы можем замерить время на выполнение и спланировать вызов раньше или позже.

- Преимущество setTimeout перед setInterval
КСТАТИ Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.

Сравниваем:

1) setInterval
let i = 1;
setInterval(function() {
  func(i);
}, 100);

2) Вложенный setTimeout
let i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);

Для setIntervalвнутренний планировщик выполняет func(i) каждые 100 мс.
Но время, затраченное на вызовы func учитывается в эти 100 мс.
Потому РЕАЛЬНАЯ ЗАДЕРЖКА между вызовами будет меньше, чем указано нами в коде.

А если func будет выполняться дольше, чем 100 мс?
Тогда движок дождётся окончания func и проверит планировщик. Если время истекло - функция немедленно запускается вновь.

А вот вложенный setTimeout гарантирует фиксированную задержку, не учитывающую выполнение функции.

- Сборка мусора и колбэк setTimeout / setInterval.
Когда функция передаётся в setInterval / setTimeout - на неё создаётся внутренняя ссылка, которая сохраняетися в планировщике.
Это предотвращает попадание функции в сборщик мусора, даже если нет других ссылок на неё.

setTimeout(function() {...}, 100); //# данная функция будет оставаться в памяти, пока планировщик будет обращаться к ней.

Т.О. setInterval функция остаётся в памяти до тех пор, пока не будет вызван clearInterval.

Есть у этого и побочные эффекты. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, все внешние
переменные будут существовать вместе с ней. И они могут занимать приличный объём памяти.
Потому регулярные вызову функции лучше отменять, если они больше не нужны, какого бы размера не была функция.

- setTimeout с нулевой задержкой.
Особый варианет использования: setTimeout(func, 0) = setTimeout(func) (ведь по умолчанию задержка = 0).

Это планирует вызов func настолько быстро, насколько это вообще возможно.
Таким образом планировщик булет выполнять функцию сразу же после завершения выполнения предыдущей.

Пример:
setTimeout(() => alert("Мир"));
alert("Привет");

Здесь будет моментально выведено сообщение "Привет Мир".
Почему сначала привет? Планировщик проверит календарь только после выполнения текущего кода.

Случаи с более продвинутым использованием нулевой задержки в браузерах рассмотрим в теме "Событийный цикл: микрозадачи и макрозадачи".

- Ограничение браузеров на внутренние счётчики
Браузеры устанавливают ограничение на то, как часто внутренние счётчики могут выполняться.
Стандарт HTML5 говорит: "После 5-и вложенных таймеров интервал должен составлять не менее 4 миллисекунд".

Пример того, что это значит:
let start = Date.now();
let times = [];
  setTimeout(function run() {
  times.push(Date.now() - start); //# запоминаем задержку от предыдущего вызова

  if (start + 100 < Date.now()) alert(times); //# показываем задержку через 100 мс
  else setTimeout(run); //# если нужно ещё запланировать
});
//#Вывод: 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100

Первый таймер стартует сразу же, а затем в силу вступают ограничения и мы видим 9, 15, 20...

Если используем setInterval получим то же самое: первые несколько раз функция будет запущена с задержкой 0, а затем с 4+ мс.

Данное ограничение существует уже очень давно, есть множество скриптов, полагающихся на него. Поэтому оно сохраняется до сих пор.

Серверный JS не имеет такого ограничения! Но там есть и другие способы планирования асинхронных задач: setImmediate для Node.js.
Поэтому данное ограничение (5-ая задержка = 4+ мс) относится ТОЛЬКО К БРАУЗЕРАМ!

- ИТОГО
1) Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют выполнять func 1 раз или регулярно с задержкой delay (в мс).
2) Отмена выполнения необходимо вызвать clearInterval/ clearTimeout со значением, которое возвращают методы setInterval/ setTimeout.
3) Вложенный вызов setTimeout является более гибклй альтернативой setInterval. Также он позволяет более точно задавать интервалы между выполнениями.
4) Планирование с 0-ой задержкой setTimeout(func, 0) или setTimeout(func) используется для вызова функции сразу по завершению выполнения текущего кода.
5) Браузер ограничивает 4-мя мс каждую пятую запланированную функцию с 0-ой задержкой.

Все методы планирования НЕ ГАРАНТИРУЮТ точную задержку по некоторым причинам:
1) Процессор может быть перегружен;
2) Вкладка браузера может находиться в фоновом режиме;
3) Если ноутбук работает от аккумулятора.

Всё это может увеличить интервал срабатывания таймера до 300, а то и до 1000 мс, в зависимости от браузера и ПК.