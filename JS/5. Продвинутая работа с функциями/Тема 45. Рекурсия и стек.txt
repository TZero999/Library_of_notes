- Рекурсия и стек
Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных,
но более простых задач.

В процессе выполнения этой задачи в теле одной функции может быть вызвана другая функция. 
Частный случай данной ситуации - это "рекурсия", когда ФУНКЦИЯ ВЫЗЫВАЕТ САМА СЕБЯ.

Пример:
    Напишем функцию pow(x, n), которая будет возводить x в натуральную степень n раз.

    Есть 2 способа её реализации:
    - цикл for:
        function pow(x, n) {
        let result = 1;
      #умножаем result на x n раз в цикле
            for (let i = 0; i < n; i++) {
            result *= x;
            }
            return result;
        }
    alert( pow(2, 3) ); // 8

    - Рекурсивный способ:
    function pow(x, n) {
        if (n == 1) {
          return x;
        } else {
          return x * pow(x, n - 1);
        }
    }
    alert( pow(2, 3) ); // 8
.

Рекурсивный вариант отличается даже логикой исполнения.
Так, когда функция pow(x, n) вызывается - исполнение делится на 2 ветви:
1) if n==1 #=x;
2) else x * pow (x, n-1).

1-ая ветвь - "База рекурсии". 
Она сразу же приводит к очевидному результату, ведь pow(x,1) = x.

2- ая ветвь отображает математическую аналогию записи степени числа: x^n = x * x^(n-1).
Эта ветвь - "шаг рекурсии". С помощью неё мы сводим задачу к более простому действию и более простой аналогичной задаче.
Последующие шаги упрощаются до тех пор, пока n не станет равно 1.

Профессионально это называется так:
"Функция pow рекурсивно вызывает сама себя до n==1"

- Обычно рекурсивное решение короче
К тому же в приведённом примере можно использовать "условный оператор ?".
Получим короткую, но всё ещё легко читаемую запись:
    function pow(x, n) {
        return (n==1) ? x : (x* pow(x, n-1));
}

Количество вложенных вызовов (включая первый) - "Глубина рекурсии". В нашем случае она равна n.

Движки JS ограничивает максимальную глубину рекурсии. Точное число рекурсий, которые может задействовать пользователь - минимум 10 000. 
Некоторые интерпретаторы поддерживают глубину рекурсии до 100 000.

- Контекст выполнения, стек.
Заглянем под капот движка JS.
Информация о процессе выполнения запущенной функции хранится в её "контексте выполнения" (Execution context).

Контекст выполнения - специальная внутренняя структура данных, содержащая информацию о вызове функции.
Она включает в себя контекстное место в коде, на котором находится интерпретатор, локальные переменные функции, хначение this и др. служ. информацию.

1 вызов функции = 1 контекст выполнения.

А вот когда функция производит ВЛОЖЕННЫЙ вызов - происходит следующее:
1) Выполнение функции приостанавливается;
2) Контекст выполнения, связанный с ней, запоминается в "стеке контекстов выполнения"
3) Выполняется ВЛОЖЕННЫЕ вызовы, для КАЖДОГО вложенного вызова создаётся СВОЙ "контекст выполнения".
4) После их завершения старый контекст достаётся из "стека контекста выполнения" и выполнение внешней функции возобновляется.

- Рекурсивный обход
Ещё одно отличное применение рекурсии.

Предположим, у нас есть компания:
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};

По итогу в коде видно, что у нас есть отделы внутри компании.
* Отдел может состоять из массива работников.
* Отдел может быть поделён на подотдеты
* При росте подотдела он делится на подразделения (команды)

Теперь, что мы можем сделать, чтобы получить суммы всех зарплат?
  Итеративный подход будет проблематичным - структура слишком сложная.
  Можно сделать цикл for поверх объекта company с вложенным циклом над отделами 1-го уровнявложенности.
  Вот только затем нам понадобится больше вложенных циклов для итераций над сотрудниками отделов второго уровня и т.д.

Попробуем рекурсию.
  Когда наша функция получает отдел для подсчёта суммы зарплат - есть 2 варианта исхода:
  1. Это либо "простой" отдел с массивом (тогда можно суммировать зарплаты в цикле).
  2. Это объект N с подотделами - тогда мы сможем сделать N рекурсивных вызовов, чтобы получить сумму каждого из подотделов и объединить результаты.

  Случай 1, когда мы получаем готовый массив, - это база рекурсии.
  Случай 2, когда получение объекта - это шаг рекурсии. Сложная задача разбивается на задачи для подотделов. 
  В свою очередь они могут вновь разделиться на более мелкие подотделы. Рано или поздно это разделение завершится и всё сведётся к случаю 1.

Получаем:
  #Функция для подсчёта суммы зарплат
  function sumSalaries(department) {
  
  if (Array.isArray(department)) { //# случай (1)
    return department.reduce((prev, current) => prev + current.salary, 0); //# сумма элементов массива
  } else { //# случай (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); //# рекурсивно вызывается для подотделов, суммируя результаты
    }
    return sum;
  }
}
alert(sumSalaries(company)); //# 6700

Принцип прост: для объекта {...} используются рекурсивные вызовы, а массивы [...] являются «листьями» дерева рекурсии, они сразу дают результат.
Кстати, в коде используются возможности, о которых мы говорили ранее:

Метод "arr.reduce" из главы "Методы массивов" для получения суммы элементов массива.
Цикл "for(val of Object.values(obj))" для итерации по значениям объекта: Object.values возвращает массив значений.

- Рекурсивные структуры
Рекурсивная структура данных - структурв, повторяющая саму себя в своих частях.

В примере выше такие структуры присутствовали.
ОТДЕЛ компании это:
* Либо массив людей
* Либо объект с отделами

Для веб-разработчиков существует более известные примеры: HTML- и XML-документы.
В HTML-документе теги могут содержать:
* Фрагменты текста.
* HTML-комментарии.
* Другие теги (а они могут содержать вышеперечисленное).

Это снова рекурсивное определение.

- Связанный список - "альтернатива" массиву
Предположим, мы хотим хранить упорядоченный список объектов.
Естественным выбором будет использование для этого массива:

let arr = [obj1, obj2, obj3];

Но у массивов ведь есть недостатки: "дороговизна" удаления и вставки элементов.
Ведь arr.unshift(obj) должна проиндексировать все элементы массива, чтобы освободить место для нового obj.
Если массив большой - это займёт много времени. arr.shift(obj) это тоже касается.

Не потребуют переиндексации только операции, которые будут выполняться с конца массива: arr.push() и arr.pop().
Выходит, что массив вызывает много проблем, если нам необходимо работать с его началом.

Если нам необходимо осуществить быструю вставку или удаление из любой части массива лучше рассмотреть структуру, которая называется "связанный список".

Элемент связанного списка определяется рекурсивно как объект с:
* value,
* next - свойство, ссылающееся на следующий элемент списка (или null, если это последний элемент).

Пример:

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

Альтернативный, более наглядный код создания связанного списка:
  let list = { value: 1 };
  list.next = { value: 2 };
  list.next.next = { value: 3 };
list.next.next.next = { value: 4 }; 

Получается, у нас есть несколько объектов, каждый имеет свойство "value"  и "next".
Переменная list - первый объект в цепочке. Следуя по указателям "next" мы можем попасть в любой её элемент.

Список всегда можно разделить на несколько, а потом "склеить" заново:
  let secondList = list.next.next;
  list.next.next = null;
Стоит заметить, что часть списка не просто копируется, а именно "вырезается".

Объединение списка происходит простой командой:
list.next.next = secondList;

И, естественно, мы можем спокойно вставлять и удадять элементы из любого места списка.

Вот пример добавления нового элемента в список. Для этого нужно обновить ("сдвинуть") первый элемент списка:
  //# Создаём список:
  let list = { value: 1 };
  list.next = { value: 2 };
  list.next.next = { value: 3 };
  list.next.next.next = { value: 4 };

  //# Добавляем новый элемент в список:
list = { value: "new item", next: list };

Чтобы удалить элемент из середины списка нам необходимо изменить значение next предыдущего элемента:
list.next = list.next.next;

Так, list.next перепрышгет с положения 1 на положение 2. Значение 1 будет исключено из цепочки.
Если оно нигде не хранится - оно будет очищено из памяти.

В отличие от массивов здесь нет перенумерации, а значит элементы легко подвергаются "ротации".
Но списки явно не всегда лучше массивов. Иначе бы о массивах все забыли бы.

- Недостаток связанных списков
Главный недостаток связанных списков в том, что у нас нет возможности легко получить доступ к элементу по индексу.
В простом массиве мы используем arr[N] как прямую ссылку. Но в писке нам придётся начать с элемента №1 и перейти N раз в "next" элемент.

Списки можно УЛУЧШИТЬ:
* Добавить свойство "prev".
  "prev" поможет легко двигаться по списку в обратную сторону.
* Добавить переменную "tail"
"tail" будет ссылаться на последний элемент списка. Эту переменную надо будет обновлять при изменении списка.
* Возможны и другие изменения...
Главное, чтобы структура данных соответствовала задачам с точки зрения производительности и удобства.

- ИТОГО
Рекурсия - термин в программировании, означающий вызов функцией самой себя.

Когда функция вызывает сама себя - это "шаг рекурсии". 
"База рекурсии" - это аргумент функции, который делает задачу настолько простой, что дальнейшие шаги рекурсии не требуются.

РЕКУРСИВНО ОПРЕДЕЛЯЕМАЯ структура данных - это структура данных, которая может быть определена с использованием самой себя.
Пример - связанный список, который может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список.
list = { value, next -> list }

"Деревья", такие как деревья HTML-элементов, могут содержать в ветвях другие ветви. Следовательно они рекурсивны.

