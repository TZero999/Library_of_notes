Многие встроенные функции JS поддерживают произвольное количество аргументов.

Например:
* Math.max (arg1, arg2, ..., argN) - находит максимальное значение;
* Object.assign(dest, src1, ..., srcN) - копирует свойство объекта в целевой объект dest.

- Остаточные параметры (...)

Вызывать функцию можно с любым количеством аргументов:

function sum(a,b) {
    return a+b;
}
alert( sum(1, 2, 3, 4, 5));

Наличие лишних аргументов не вызовет ошибку, но функция посчитает только первые два.

Остаточные параметры могут быть обозначены ТРОЕТОЧИЕМ. 
Для функции это будет означать: "Собери оставшиеся параметры и положи их в массив".

Опробуем этот трюк:
    function sumAll(...args) { //# args — имя для массива
    let sum = 0;
    for (let arg of args) sum += arg;
    return sum;
  }
  
  alert( sumAll(1) ); // 1
  alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6

Здесь мы не указываем, сколько будет аргументов у функции.
Но мы можем положить несколько первых параметров в переменные, а остальные - собрать в массив.

В функцие ниже мы используем первые два аргумента как имя и фамилию, а все последующие отправятся в массив titles:
    function showName(firstName, lastName, ...titles) {
    alert( firstName + ' ' + lastName ); // Юлий Цезарь
  
    // Оставшиеся параметры пойдут в массив
    // titles = ["Консул", "Император"]
    alert( titles[0] ); // Консул
    alert( titles[1] ); // Император
    alert( titles.length ); // 2
}
showName("Юлий", "Цезарь", "Консул", "Император");

ВАЖНОЕ УТОЧНЕНИЕ: "(...) всегда в конце!"
Остаточные параметры всегда должны находиться в конце списка аргументов. Иначе получим ошибку.

- Переменная "arguments"
Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами:
  function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );
}
//# Кстати, объект arguments можно перебирать: for (let arg of arguments) alert(arg);

showName("Юлий", "Цезарь"); //# Вывод: 2, Юлий, Цезарь
showName("Илья"); //# Вывод: 1, Илья, undefined (второго аргумента нет, но он ожидается).

Раньше в языке не было остаточных параметров, получить все аргументы функции можно было только с помощью "arguments".
Этот способ всё ещё работает, его можно найти в старом коде.

Но у него есть серьёзный недостаток: arguments похож на массив и его тоже можно перебирать - это не массив.
Он не поддерживает методы массивов (нельзя использовать, например, arguments.map(...)).

К тому же, arguments ВСЕГДА содержит ВСЕ аргументы функции - МЫ НЕ МОЖЕМ ПОЛУЧИТЬ ИХ ЧАСТЬ.
Остаточные параметры позволяют это сделать.

Соответсвенно, ДЛЯ более удобной РАБОТЫ С АРГУМЕНТАМИ ЛУЧШЕ ИСПОЛЬЗОВАТЬ ОСТАТОЧНЫЕ ПАРАМЕТРЫ.

"Стрелочные функции не имеют "arguments" ".
Если обращаться к "arguments" из стрелочной функции - получим аргументы внешней "нормальной" функции:
  function f() {
  let showArg = () => alert(arguments[0]);
  showArg(2);
}
f(1); //# 1

Следовательно, у стрелочной функции нет не только собственного "this", но и своего объекта "arguments".

- Оператор расширения
Теперь мы можем получить массив из списка параметров.
Но иногда необходимо сделать противоположное: получить аргументы из массива.

Например, Math.max:
alert( Math.max(3, 5, 1) ); //# 5

Если есть массив чисел arr = [3, 5, 1].
Как же вызвать для него Math.max?

Если попробуем "Math.max(arr)" - получим "NaN".

Теоретически можно было бы сделать всё вручную или продумать использование цикла:
Math.max(arr[0], arr[1], arr[2]) //# 5.

НО:
1) Аргументов может быть очень много / может не быть совсем;
2) Мы не всегда знаем, сколько вообще будет аргументов.

Здесь нам поможет "ОПЕРАТОР РАСШИРЕНИЯ".
Он похож на остаточные параметры (тоже использует ...).

Пример:
  let arr = [3, 5, 1];
alert( Math.max(...arr)); //# 5

Оператор "..." "открывает" массив и берёт из него список аргументов.

Таким образом можно передать и несколько объектов:
  let arr1 = [1, -2, 3, 4];
  let arr2 = [8, 3, -8, 1];
alert( Math.max(...arr1, ...arr2) ); //# 8

И даже комбинировать оператор расширения с обычными значениями:
  let arr1 = [1, -2, 3, 4];
  let arr2 = [8, 3, -8, 1];
alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); //# 25

С помощью оператора расширения можно осуществить даже СЛИЯНИЕ МАССИВОВ!
  let arr = [3, 5, 1];
  let arr2 = [8, 9, 15];
  let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2);

Но оператор расширения работает не только с массивами, но и с перебираемыми объектами.
Тапример, оператором расширения можно довольно просто ПРЕВРАТИТЬ СТРОКУ В МАССИВ СИМВОЛОВ:
  let str = "Привет";
  let arr = [...str];
  alert( arr ); //# [П,р,и,в,е,т]
  //# используем аналог:
alert( Array.from(str) ); //# [П,р,и,в,е,т]

Однако между Array.from(obj) и [...obj] есть разница:
* Array.from работает и с псевдомассивами, и с итерируемыми объектами.
* Оператор расширения [...] работает с итерируемыми объектами.

Выходит, что если нам надо СДЕЛАТЬ ИЗ ЧЕГО-ЛИБО МАССИВ - ПРЕДПОЧТИТЕЛЬНЕЕ использовать Array.from(obj).

- ИТОГО

Если видим в коде "..." - это могут быть или остаточные параметры, или операторы расширения.

Как их отличить:
"..." в конце списка аргументов? Это "Остаточные параметры". Он собирает неуказанные аргументы в массив;
"..." в вызове функции или где-то еще? - Это "Оператор расширения". Он поочерёдно извлекает из массива элементы.

Полезно запомнить следующее:
"Остаточные параметры" используются, чтобы создавать новые функции с неопределённым числом аргументов.
"Оператор расширения" может вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.

Обе эти конструкции позволяют легко преобразовывать наборы значений в массивы и обратно.
К аргументам функции можно обращаться и по старому - через псевдомассив "arguments".