JS предоставляет огромный набор довольно гибких возможностей для работы с функциями.
Так, функции можно передавать в другие функции, использовать как объекты и т.д.

В этой теме рассмотрим, как перенаправлять вызовы между функциями и как их декорировать.

- Прозрачное кеширование:
Пускай у нас есть функция slow(x). Она выполняет ресурсоёмкие вычисления, но возвращает стабильные результаты.
Другими словами, для одного и того же x функция возвращает один и тот же результат.

Если функция выполняется часто - мы можем захотеть запоминать возвращаемые ей результаты - "кэшировать" их.

Вместо того, чтобы усложнять функцию slow(x) мы можем обернуть её в функцию-обёртку "wrapper", которая добавит нам функцию кэширования.
В таком подходе масса преимуществ.

Пример:
function slow(x) { 
    /* #здесь какие-то ресурсоёмкие вычисления# */
    alert(`Called with ${x}`);
    return x;
  }
  
  function cachingDecorator(func) {
    let cache = new Map();
  
    return function(x) {
      if (cache.has(x)) {    //# Кеш содержит такой x?,
        return cache.get(x); //# Тогда читаем из него результат
      }
  
      let result = func(x); //# иначе вызываем функцию
  
      cache.set(x, result); //# и кешируем результат
      return result;
    };
  }
  
  slow = cachingDecorator(slow);

alert( slow(1) ); //# Вызываем slow(1) и кешируем результат
alert( "Again: " + slow(1) ); //# возвращаем из кеша
alert( slow(2) ); //# Вызываем slow(2) и кешируем результат
alert( "Again: " + slow(2) ); //# возвращаем из кеша

В коде выше cachingDecorator - это специальная функция - декоратор.
Она принимает другую функцию и изменяет её поведение.

Идея следующая:
мы можем вызвать cachingDecoratorс любой функцией. В результате мы получим кеширующую обёртку.
Это удобно - ведь у нас может быть множество функций, использующих кэширование.

К тому же это оставляет код в чистоте, т.к. функция кэширования отделена от основного кода.

Результат вызова cachingDecorator(func) является обёрткой: функция function(x) оборачивает вызов func(x) в кэширующую логику.

Так, с точки зрения внешнего кода функция slow(x) по прежнему выполняет то же самое. Обёртка лишь добавляет ей функцию кэширования.

ПРЕИМУЩЕСТВА отдельной фунции cachingDecorator:
1) функцию cachingDecorator() можно использовать повторно;
2) Логика кеширования является отдельной, таким образом не увеличивая сложность и читаемость slow(x);
3) Несколько декораторов можно объединить между собой (об этом позже).

- Применение func.call для передачи контекста
Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

Например, в приведённом ниже коде функция worker.slow() перестаёт работать после применения к ней декоратора:

let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    //# здесь какая-нибудь страшно тяжёлая задача для процессора
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

//# А тут тот же код, что и выше:
function cachingDecorator(func) {
  let cache = new Map();
  return function(x)
   {
    if (cache.has(x)) {
      return cache.get(x);
    }

    let result = func(x); // (**)
    
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); //# Оригинальный метод работает

worker.slow = cachingDecorator(worker.slow);//# Делаем его кеширующим
alert( worker.slow(2) ); //# Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'

Ошибка возникает в строке (*). 
Функция пытается получить доступ к this.someMethod, но завершается с ошибкой.

Причина в том, что в строке (**) декоратор вызывает оригинальную функцию func(x), а она получает this = undefined.

Мы бы наблюдали такую же картину, есди бы запустили код:
let func = worker.slow;
func(2);

Т.е. декоратор передаёт вызов оригинальному методу, но уже без контекста.

Исправить это можно при помощи специального метода функции func.call(context, ...args).
Он позволяет вызывать функцию явно устанавливая this.

Синтаксис:
func.call(context, arg1, arg2, ...)

Этот метод запускает функцию funcи использует первый аргумент как её контекст this, а все последующие - как её аргументы.

Проще говоря, два вызова ниже по сути делают одно и то же:
func(1,2,3) == func.call(obj, 1, 2, 3);

Оба вызывают функцию с аргументами 1, 2 и 3. Отличие одно - func.call ещё и устанавливает this = obj.

- Пример:
Вызываем функцию sayHi в контексте различных объектов:
sayHi.call(user) запускает sayHi, передавая this=user.
Следующая строка устанавливает this=admin.

//#Сама функция:
function sayHi() {
    alert(this.name);
  }
  
  let user = { name: "John" };
  let admin = { name: "Admin" };
  
//# используем 'call' для передачи различных объектов в качестве 'this':
sayHi.call( user ); // John
sayHi.call( admin ); // Admin

//# Используем call для вызова say с заданным контекством фразой:
unction say(phrase) {
    alert(this.name + ': ' + phrase);
    }
let user = { name: 'John'}; 
say.call( user, 'Hello'); //# видим John: Hello, т.к. user становится this, а Hello - первый аргумент.

//# Можем использовать call в обёртке для передачи контекста в исходную функцию:
let worker = {
    someMethod() {
      return 1;
    },
  
    slow(x) {
      alert("Called with " + x);
      return x * this.someMethod(); // (*)
    }
  };
  
  function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
      if (cache.has(x)) {
        return cache.get(x);
      }
      let result = func.call(this, x); // теперь 'this' передаётся правильно
      cache.set(x, result);
      return result;
    };
  }
  
  worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей
  
alert( worker.slow(2) ); // работает
alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)

Как передаётся this:
1) worker.slow (после декорации) становится обёрткой для function(x){...};
2) При выполнении worker.slow(2) обёртка получает 2 в качестве аргумента для this=worker (т.к. это объект перед точкой);
3) Внутри обёртки (если результат не кэширован), func.call(this, x) передаёт текущий this(который равен worker) и текущий аргумент (=2) в оригинальную функцию.

- Несколько аргументов с "func.apply"
До сих пор cachingDecorator работал только с одним аргументом.

Разберёмся, как кэшировать метод с несколькими аргументами:
let worker = {
  slow(min, max) { //# здесь может быть какая-то тяжёлая задача
    return min + max; 
  }
};
worker.slow = cachingDecorator(worker.slow); //# будет кешировать вызовы с одинаковыми аргументами 

* Здесь необходимо решить следующую задачу:
  Надо использовать сразу два аргумента min и max для ключа коллекции cache.
Для одного аргумента мы просто сохраняли результат с помощью cache.set(x, result) и получали его через cache.get(x).
Теперь же нам нужно запомнить результат комбинации аргументов (min и max). 
Встроенный Map принимает только 1 значение в качестве ключа.

Есть несколько решений данной задачи:
1) Реализовать новую (или использовать стороннюю) структуру данных для коллекции, более универсальной, чем Map - реализуемо, но муторно;
2) Использовать вложенные коллекции: cache.set(min) будет вложено в коллекцию Map, которая уже хранит пару (max, result).
Тогда получить result можно будет вызвав cache.get(min).get(max) - но это только для двух аргументов. Что если их будет ещё больше...?
3) Соединить два значения в одно. Например, в нашем случае можно использовать строку "min,max" как ключ для Map.
Для гибкости можно передавать хэширующую функцию в декоратор, которая сама знает, как сделать одно значение из нескольких.

В основном практическое применение нашёл третий вариант Он достаточно хорош, поэтому используем его.

К тому же надо заменить функцию func.call(this,x) на func.call(this, ...arguments), чтобы передавать все аргументы обёрнутой функции.

Получаем такой вариант cachingDecorator:
let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); //# (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); //# (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // работает
alert( "Again " + worker.slow(3, 5) ); //# аналогично (из кеша)

Такой код работает с любым количеством аргументов.

Тут есть 2 отличия:
1) В строке (*) вызываем hash для создания одного ключа из нескольких аргументов arguments. Здесь мы используем простую функцию "объединения".
Так из аргументов (3, 5) мы получаем ключ "3,5". В более сложных ситуациях могут понадобиться другие функции хэширования.

2) В строке (**) используем func.call(this, ...arguments) дял передачи как контекста, так и всех аргументов, полученных обёрткой в исходную функцию.

Вместо func.call(this, ...arguments) можно написать func.apply(this.arguments).

Синтаксис встроенного метода func.apply:
func.apply(context, args).

Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.

Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов, в то время как apply принимает псевдомассив.

Эти два вызова почти эквивалентны:
func.call(context, ...args); //# Передаёт массив как список с оператором расширения.
func.apply(context, args);   //# Тот же самый эффект

Есть только одна небольшая разница:
Оператор расширения "..." позволяет передавать ПЕРЕБИРАЕМЫЙ объект args в виде списка в call. Apply принимает только псевдомассив "args".
Так что эти вызовы дополняют друг друга.

* КАКОЙ ВЫЗОВ ВЫБРАТЬ: Call или Apply?
Если у нас есть перебираемый объект - сработает Call. Где ожидаем псевдомассив - Apply.

Если у нас есть объект, который и то, и другое - реальный массив - мы можем использовать любой метод, но Apply предпочтительнее, так
как большинство движков JS оптимизируют его лучше.

Передача ВСЕХ АРГУМЕНТОВ вместе С КОНТЕКСТОМ другой функции называется "ПЕРЕНАПРАВЛЕНИЕ ВЫЗОВА".
Простейший пример перенаправления:

let wrapper = function() {
  return func.apply(this, arguments);
};
При вызове wrapper из внешнего кода его будет не отличить от вызова исходной функции.

- Заимствование метода

Теперь разберёмся с ещё одним небольшим улучшением функции хэширования:

function hash(args) {
  return args[0] + ',' + args[1];
}

В таком виде она работает только для двух аргументов.
Сделаем так, чтобы она могла склеить любое количество аргументов args.

Чисто теоретически решением было бы использовать метод arr.join:
function hash(args) { return args.join(,) }
Вот только это не сработает, так как мы вызываем hash(arguments), а объект arguments является перебираемым (коллекция, которую можно перебрать в цикле
for...of) и псевдомассивом (объект со структурой массива, но не обладает методами массива), но не реальным массивом.

Т.О. вызов join для него не сработает: получим ошибку "arguments.join не является функцией".

- Как заставить join работать?
Чтобы заставить join работать мы используем трюк - "заимствование кода":
function hash() {
  alert( [].join.call(arguments) ); //# 1,2
}
hash(1, 2);

МЫ берём метод join (заимствуем) из обычного массива [].join
Затем используем [].join.call, чтобы выполнить его в контексте arguments.

Как это работает?
Внутренний алгоритм метода arr.join(glue) очень прост. Следующие пункты взяты из спецификации "почти как есть":
1) Первый аргумент - glue. Если аргументов нет - им будет запятая.
2) Пускай result - пустая строка "".
3) Добавим this[0] к пусторй строке result.
4) Дабавим glue и this[1].
5) Добавим glue и this[2].
6) Выполняем до тех пор, пока this.length элементов не будет склеено.
7) Возвращаем результат result.

Проще говоря: технически arr.join принимает this и объединяет this[0], this[1] и т.д. вместе.
Он намеренно написан так, что допускает любой псевдомассив this (этой практике следуют практике). 

- ИТОГО
Декоратор - это обёрька вокруг функции, которая изменяет поведение последней.
Но основная работа по прежнему остаётся на основной функции, обёрнутой wrapper-ом.

Обычно довольно безопасно заменять функцию методом декорирования, за исключением одного случая:
Если исходная функция предоставляет свойства как func.calledCount или типа того - декорированная функция их не предоставит, т.к. это - обычная обёртка.
У неё, грубо говоря, нет своего this.

Декораторы можно рассматривать как "дополнительные возможности" или "аспекты", которые можно добавить функции, не усложняя её.

Для реализации cachingDecorator мы изучили 2 метода:
1) func.call(context, arg1, arg2...) - вызывает func с данным контекстом и аргументами.
2) func.apply(context, args) - вызывает func, передавая context как this и псевдомассив args как список аргументов.

Также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте другого объекта.
Весьма распространено заимствовать методы массива и пременять их к аргументам arguments.
В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.

На практике декораторы используются для решения самых разных задач.