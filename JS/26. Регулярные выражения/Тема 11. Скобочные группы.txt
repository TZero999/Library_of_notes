* СКОБОЧНЫЕ ГРУППЫ
Часть шаблона допустимо заключать в круглые скобки ().
Это называется "Скобочная группа".

У этого выделения есть 2 эффекта:
1) Позволяет поместить часть совпадения в отдельный массив;
2) Если установить квантификатор после скобок - он будет применяться ко всем содержимому скобки.

* ПРИМЕР 'gogogo':
Если мы напишем шаблон /go+/ регулярка будет искать символ "g", после которого идёт хотя бы один символ "o".
Символ "o" может повторяться сколь угодно раз. Шаблон будет находить "go", "goooo", "goooooooo" и т.д.

Вместо того, чтобы писать сложный шаблон мы можем использовать скобочную группу.
# Вот так: 
{   
    let str = 'Gogogo now!' 
    alert( str.match(/(go)+/ig) ); //# ["Gogogo"]
}

* ПРИМЕРЫ с доменами:
{   
    hostname('gmail.com');                                  //# [ 'gmail.com' ]
    hostname('users.gmail.com');                            //# [ 'users.gmail.com' ]
    hostname('learn.javascript.ru/regexp-groups');          //# [ 'learn.javascript.ru' ]
    
    function hostname(str){
        console.log(result = str.match(/(\w+\.)+\w+/g));
    }
}

Возможно шаблон стоило бы изменить на /[-.\w]+@([\w-]+\.)+[\w-]+/g, чтобы учитывать домены, в которых есть дефис "-".

* СОДЕРЖИМОЕ СКОБОК В match():
Поисковый движок запоминает содержимое каждой скобочной группы.
Это позволяет получить результат по каждой отдельной скобочной группе.

Метод str.match(regexp) (если у регулярки regexp нет флага g!!!), ищет первое совпадение и возвращает его в виде массива:

Позиция 0 - всё совпадение целиком.
Позиция 1 – содержимое первой скобочной группы.
Позиция 2 – содержимое второй скобочной группы.
И т.д…

Причём, к слову, на выходе мы получим не массив, а строку!

# Пример:
{
    let str = '<h1>Hello, world!</h1>';
    let tag = str.match(/<(.*?)>/);
    alert( tag[0] ); //# <h1>
    alert( tag[1] ); //# h1
}

Невероятно удобная штука. Однако я не зря выделил фразу "если у регулярки regexp нет флага g!!!".
Порой скобочная группа может работать не так, как хотелось бы. Виной этому вполне может оказаться флаг "g".
Потому несмотря на все удобства стоит быть внимательным, особенно если ваш tag[1] и т.п. возвращает
"undefined", вместо результата.

* ВЛОЖЕННЫЕ ГРУППЫ:
Скобки могут быть вложенными.

Так, например, в <span class="my"> нас может интересовать:
1) Всё содержимое тега;
2) Название тега;
3) Атрибуты тега.

# Пример подходящего для всех 3-ёх случаев шаблона:
{
    let str = '<span class="my">';
    let regexp = /<(([a-z]+)\s*([^>]*))>/;
    let result = str.match(regexp);

    alert(result[0]); //# <span class="my">
    alert(result[1]); //# span class="my"
    alert(result[2]); //# span
    alert(result[3]); //# class="my"
}

* НЕОБЯЗАТЕЛЬНЫЕ ГРУППЫ
Даже если скобочная группа "необязательная" (то бишь имеет после себя квантификатор "?"),
соответствующий элемент массива всё равно существует и имеет тип undefined.

# Пример:
{
    let match = 'a'.match(/a(z)?(c)?/);
    alert( match.length ); //# 3
    alert( match[0] ); //# a (совпадение)

    alert( match[1] ); //# тут undefined
    alert( match[2] ); //# и тут undefined
}

Как видно, массив имеет длину 3, причём скобочные группы пусты и имеют значение undefined.

А теперь ещё более "приятный" пример:
{
    let match = 'ac'.match(/a(z)?(c)?/)
    
    alert( match.length ); //# 3
    alert( match[0] ); //# ac (совпадение)
    alert( match[1] ); //# тут undefined
    alert( match[2] ); //# а тут совпадение "c"
}

Длина массива равна 3, но для группы (z)? ничего нет, поэтому результат: ["ac", undefined, "c"].
Неприятная особенность. 

КАК БОРОТЬСЯ С ТАКИМ ПОВЕДЕНИЕ - СМ. "ИСКЛЮЧЕНИЕ ИЗ ЗАПОМИНАНИЯ"

* ПОИСК ВСЕХ СОВПАДЕНИЙ С ГРУППАМИ: matchAll()
! matchAll довольно новая функция, может понадобиться полифил.

При поиске всех совпадений (флаг "g") метод match не вернёт нам значения для  скобочных групп.
{
    let str = '<h1> <h2>';
    let tags = str.match(/<(.*?)>/g);
    
    alert( tags );     // [ '<h1>','<h2>' ]
    alert ( tags[0] ); //# h1
    alert ( tags[1] ); //# h2
}

Результат – массив совпадений, но без деталей о каждом. 
Но на практике скобочные группы тоже часто нужны.

Здесь мы можем использовать метод str.matchAll(regexp).
Он, как и str.match(regexp), ищет совпадения, но у него есть три отличия:
1) Возвращает  НЕ МАССИВ, а ПЕРЕБИРАЕМЫЙ ОБЪЕКТ;
2) При наличии флага "g" возвращает каждое совпадение в виде массива со скобочными группами;
3) Если совпадений нет - возвращает пустой перебираемый объект, а не "null".

# Пример использования "matchAll":
{
    let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

    alert(results); // [object RegExp String Iterator] //# Не массив, а перебираемый объект

    alert(results[0]); //# undefined (*)

    results = Array.from(results); //# превращаем в массив
    alert(results[0]); //# <h1>,h1 (первый тег)
    alert(results[1]); //# <h2>,h2 (второй тег)
}

С "matchAll" мы не можем получить result[0], т.к. объект - не псевдомассив.
Превратить его в массив можно с помощью Array.from(result).

* ОБХОДИМСЯ БЕЗ Array.from():
Нет необходимости явно преобразовывать результат через Array.from().

Можно перебрать результаты в цикле:
{
    let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
    for(let result of results) {
    alert(result);
    //# [ '<h1>', 'h1', index: 0, input: '<h1> <h2>', groups: undefined ]
    //# [ '<h2>', 'h2', index: 5, input: '<h1> <h2>', groups: undefined ]
    }
}

А ещё можно использовать приём "деструктуризации":
{
    let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
    alert( tag1 ); //# [ '<h1>', 'h1', index: 0, input: '<h1> <h2>', groups: undefined ]
    alert( tag2 ); //# [ '<h2>', 'h2', index: 5, input: '<h1> <h2>', groups: undefined ]
}

* Почему matchAll возвращает перебираемый объект?
Причина проста - оптимизация.
При вызове matchAll движок сначала возвращает пустой объект, а поиск и его заполнение производится
по мере того, как мы запрашиваем результат.

Таким образом мы получим столько результатов, сколько нам надо, без лишней работы.
Так, если в тексте 100 совпадений, а в цикле после 5-го совпадения мы сделали "break" движок
не станет тратить время на поиск остальных 95-и совпадений.

* ИМЕНОВАННЫЕ ГРУППЫ
В сложных регулярных выражениях часто сложно запомнить по номеру, в какой скобочной группе 
что отображается. Поэтому у нас есть возможность давать скобочным группам имена.

Синтаксис: /(?<name>...)/

# Пример именования скобочных групп:
{
    let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
    let str = "2019-04-30";
    let groups = str.match(dateRegexp).groups;
    
    alert(groups.year +' год');         //# 2019 год
    alert(groups.month + '-ый месяц');  //# 04-ый месяц
    alert(groups.day + '-ый день');     //# 30-ый день
}

Чтобы найти не только первую попавшуюся дату нам надо использовать флаг "g" и 
метод "matchAll":
{
    let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
    
    let str = "2019-10-30 2020-01-01";
    let results = str.matchAll(dateRegexp);

    for(let result of results) {
        let {year, month, day} = result.groups;
          alert(`${day}.${month}.${year}`);
        //# Первый вывод: 30.10.2019
        //# Второй вывод: 01.01.2020
}
}

* ИСПОЛЬЗОВАНИЯ СКОБОЧНЫХ ГРУПП ПРИ ЗАМЕНЕ:
Метод str.replace(regexp, replacement), осуществляющий замену совпадений с regexp в строке "str"
может заменять даже скобочные группы целиком.

Синтаксис: str.replace(regexp, '$n'), где n - номер скобочной группы.
# Пример:
{
    let str = "John Bull";
    let regexp = /(\w+) (\w+)/;
    alert( str.replace(regexp, '$2, $1') ); //# поменяли местами: "Bull, John"
}

# Пример для именованных скобочных групп:
{
    let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
    let str = "2019-10-30, 2020-01-01";
    alert( str.replace(regexp, '$<day>.$<month>.$<year>') );
    //# 30.10.2019, 01.01.2020
}

* ИСКЛЮЧЕНИЕ ИЗ ЗАПОМИНАНИЯ:
Может случиться, что скобки нам нужны для правильного применения квантификатора, но их содержимое
в результате нам не требуется.

Тогда скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало "?:"
Синтаксис: /(?:...)/

# Пример
{
    let str = "Gogogo John!";
    let regexp = /(?:go)+ (\w+)/i; //# ?: исключает go из запоминания
    let result = str.match(regexp);

    alert( result[0] );     //# Gogogo John (полное совпадение)
    alert( result[1] );     //# John
    alert( result.length ); //# 2 (Лишних элементов в массиве нет)
}

* ИТОГО:
{
    Круглые скобки группируют части регулярного выражения.

    Скобочные группы нумеруются слева направо.
    Также для удобства им можно давать имена с помощью /...(?<name>...).../.


    Метод str.match возвращает скобочные группы только без флага g.
    Метод str.matchAll возвращает скобочные группы всегда.

    Если у группы нет имени её содержимое находится по номеру элемента массива: result[1].
    Если имя есть - то также в свойстве "groups"

    Содержимое скобочной группы можно заменять с помощью str.replace(regexp, $n)
    или str.replace(regexp, $<имя>).

    Результаты по скобочным группам часто присутствуют в массиве результатов даже тогда,
    когда этого не требуется. Чтобы этого избежать можно применить способ "избегания запоминания",
    добавив в начало скобочной группы символы "?:". 
    В итоге результат по данной скобочной группе не окажется в массиве результатов, но мы не
    сможем ссылаться на эти скобочные группы в случае использования "str.replace()".
}