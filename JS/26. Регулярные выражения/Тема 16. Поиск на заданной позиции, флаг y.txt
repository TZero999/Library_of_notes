Флаг "y" позволяет производить поиск на определённой позиции в исходной строке.

Часто встречающаяся задача для регулярок - "лексический разбор":
У нас есть текст на каком-то языке программирования, а нам надо получить
его структурные элементы.

Например, когда у нас есть "кусок" HTML-кода и нам надо получить теги и атрибуты.

На самом деле это довольно глубокая тема. Есть целые наборы инструментов для написания 
таких "анализаторов". 

Но даже в процессе работы обычного разработчика может возникнуть ситуация, когда надо 
прочитать что-то на заданной позиции.

Например, у нас есть строка кода 'let varname = "value"'. Нам надо прочитать из неё 
имя переменной, которое начинается с позиции 4.

Имя переменной - это слово, значит его ищем с помощью "\w+".
Для настоящего поиска имени переменной в JS нужен шаблон получше, но
сейчас не об этом.

Вызов str.match(/\w+/) найдёт только первое слово в строке,
или все слова (с флагом g), а нам нужно одно слово и именно на позиции 4.

* REGEXP.EXEC(STR)
Специальный метод для поиска с нужной позиции.
Если у regexp нет флагов "g" и "y", то этот метод будет искать первое совпадение в
строке str, прямо как str.match(regexp).

Если флаг "g" есть, то метод осуществляет поиск в строке str, начиная с позиции, 
заданной свойством "regexp.lastIndex". 
Когда совпадение найдено - regexp.lastIndex обновляется на позицию последнего совпадения.

При создании регулярки свойство lastIndex = 0.
Т.О. повторные вызовы regexp.exec возвращают совпадения по очереди, одно за другим.

Пример с флагом "g":
{
    let str = 'let varName';

    let regexp = /\w+/g;
    alert(regexp.lastIndex); //# 0 (при создании lastIndex=0)

    let word1 = regexp.exec(str);
    alert(word1[0]); //# let (первое слово)
    alert(regexp.lastIndex); //# 3 (позиция за первым совпадением)

    let word2 = regexp.exec(str);
    alert(word2[0]); //# varName (второе слово)
    alert(regexp.lastIndex); //# 11 (позиция за вторым совпадением)

    let word3 = regexp.exec(str);
    alert(word3); //# null (больше совпадений нет)
    alert(regexp.lastIndex); //# 0 (сбрасывается по окончании поиска)
}

Каждое совпадение возвращается в виде массива, со всеми скобочными группами и дополнительными
свойствами. Результат можно перебрать в цикле:
{
    let str = 'let varName';
    let regexp = /\w+/g;
    let result;

    while (result = regexp.exec(str)) {
        alert( `Найдено ${result[0]} на позиции ${result.index}` );
    //# Найдено let на позиции 0, затем найдено varName на позиции 4
}
}

Такое использование "regexp.exec" - альтернатива методу "str.matchAll".

* ХИТРОСТЬ С lastIndex - поиск с указанной позиции:
Мы можем сами указать начальную позицию "lastIndex":
{
    let str = 'let varName = "value"';
    let regexp = /\w+/g; //# без флага g свойство lastIndex проигнорируется
    regexp.lastIndex = 4;

    let word = regexp.exec(str);
    alert(word); //# varName
}

Но такой способ позволяет искать НАЧИНАЯ С указанной позиции и ДАЛЕЕ по текст.

* ФЛАГ "y" - поиск РОВНО НА ПОЗИЦИИ:
Флаг "y" позволяет указать, что поиск должен быть осуществлён строго на позиции
lastIndex, НИ ДО, НИ ПОСЛЕ!


{
    let str = 'let varName = "value"';
    let regexp = /\w+/y;

    regexp.lastIndex = 3;
    alert( regexp.exec(str) ); //# null (на позиции 3 пробел, а не слово)

    regexp.lastIndex = 4;
    alert( regexp.exec(str) ); //# varName (слово на позиции 4 было найдено)

    regexp.lastIndex = 7;
    alert( regexp.exec(str) ); //# Name (на позиции 7 была найдена часть слова)
}

Как можно видеть, регулярное выражение /\w+/y не найдено на позиции 3 (в отличие от флага g),
но найдено на позиции 4. А на позиции 7 найдена часть слова, она же и возвращена как результат.

В задачах, подобных лексическому анализу, обычно много поисков на конкретной позиции. 
Использование флага "y" – ключ к хорошей производительности.