Регулярные выражения - штука "опасная"
Даже простейшая регулярка может заставить "залагать" интерпретатор JS.

Рано или поздно с такой проблемой сталкивается каждый.

Типичный симптом: регулярное выражение обычно работает нормально, но иногда, 
с некоторыми строками, «подвешивает» интерпретатор и потребляет 100% процессора.

Веб-браузеры в таких ситуациях стараются просто "убить" процесс скрипта,
что нам навряд ли нужно.

Для серверного JavaScript это может стать серьёзной уязвимостью, 
если регулярные выражения используются для обработки пользовательских данных.

# Пример:
{
    let regexp = /^(\w+\s?)*$/;
    alert( regexp.test("A good string") ); //# true
    alert( regexp.test("Bad characters: $@#") ); //# false
}
Не стоит пытаться запускать этот пример.
На нём интерпретатор JS зависнет и нагрузит процессор по-максимуму.

А вот пример, от которого точно всё "станет колом":
{
    let regexp = /^(\w+\s?)*$/;
    let str = "An input string that takes a long time or even makes this regexp to hang!";
    alert( regexp.test(str) ); //# Этот поиск будет выполняться очень, ОЧЕНЬ долго.
}

* ПОЧЕМУ ИНТЕРПРЕТАТОР "УМИРАЕТ":
Чтобы это понять, упростим пример выше - уберём из него пробелы \s?.
Получим /^(\w+)*$/.

Для большей наглядности, заменим \w на \d. Получившееся регулярное выражение
тоже будет «зависать», но его наглядность куда лучше:
{
    let regexp = /^(\d+)*$/;
    let str = "012345678901234567890123456789!";
    alert( regexp.test(str) ); //# Этот поиск будет выполняться очень, ОЧЕНЬ долго
}

Становится заметно, что квантификатор "*" здесь выглядит лишним. Если хочется найти число,
то почему бы просто не искать "\d+".

* Что происходит во время поиска шаблона /^(\d+)*$/ в строке 123456789?:
1) Первым делом движлк находит выражение \d+. Квантификатор здесь "жадный", он захватывает все цифры, которые
только может:
\d+....... = (123456789)!

Дальше движок применяет квантификатор "*", но цифр больше нет, звёздочка ничего не даёт.
Дальше, сразу после цифр, ожидается конец строки. В строке "!". Совпадения нет.

2) Жадный квантификатор уменьшает "выборку", и возвращается на символ назад.
Теперь d - все цифры, за исключением последней:
\d+....... = (12345678)9!

3) Движок продолжает поиск с помощью квантификатора "*".
В итоге (\d+)* даёт нам второе число, "9":
\d+.......\d+ = (12345678)(9)!

Конца строки вновь не наблюдается, ведь у нас есть "!".

4) Совпадения нет - "жадный" квантификатор "+" отступает назад.

У жадных квантификаторов есть правило: последний "жадный" квантификатор уменьшает количество
повторений до тех пор, пока это вообще возможно. Затем понижаться начинает предыдущий "жадный"
квантификатор и т.д.

В итоге у нас перебираются ВСЕВОЗМОЖНЫЕ комбинации:
\d+......\d+        = (1234567)(89)!    //# 7+2
\d+......\d+\d+     = (1234567)(8)(9)!  //# 7+1+1
\d+.......\d+       = (123456)(789)!    //# 6+3
\d+.....\d+ \d+     = (123456)(78)(9)!  //# 6+2+1
И т.д. Таких комбинаций выходит довольно много.

Количество проверок вычисляется по формуле (2^n)-1, где n - длина набора.

Использование ленивого режима не исправит ситуацию: 
если мы заменим \d+ на \d+?, то регулярное выражение всё ещё будет «зависать».
Поменяется только порядок перебора, но не общее количество комбинаций.

* НАЗАД К СЛОВАМ И СТРОКАМ:
В примере с шаблоном /^(\w+\s?)*$/ и строкой "An input ... to hang!", происходит то же самое.
Каждое слово начинает дробиться на наборы типа (inp)(ut), (ha)(n)(g) и т.д.

Посмотрев на шаблон нам должно быть сразу ясно, что совпадений найдено не будет - в конце
строки мы ищем символ или пробел, а у нас там "!". Но движку это не ясно, он проверяет
кажду возможную комбинацию.

* ИСПРАВЛЯЕМ СИТУАЦИЮ:

1. Первое решение - переписать шаблон.
Перепишем регулярное выражение так: ^(\w+\s)*\w* – то есть, будем искать любое количество слов
с пробелом (\w+\s)*, после которых идёт (но не обязательно) обычное слово \w*:
{
    let regexp = /^(\w+\s)*\w*$/;
    let str = "An input string that takes a long time or even makes this regex to hang!";
    alert( regexp.test(str) ); //# false
}

Проблема исчезла, т.к. звёздочка стоит после "\w+\s", вместо "\w+\s?".
Теперь стало невозможно разбивать слова на несколько слов, букв и т.п. комбинаций.

Предыдущий шаблон (из-за необязательности \s) вообще допускал варианты
наподобие "\w+", "\w+\s", "\w+\w+" и т.п.

2. Второе решение - запрет возврата
Переписывать regexp-ы не всегда удобно, да и не всегда очевидно, как же это сделать.
Альтернативное решение проблемы - запретить квантификатору что-либо возвращать.

В шаблоне (\d+)*$ человеку очевидно, что в (\d+)* не нужно «откатывать» +. От того, что вместо
одной цифры у нас будет две независимые, идущие друг за другом цифры, ничего не изменится:
\d+........   = (123456789)!
\d+...\d+.... = (1234)(56789)!

В современных регулярных выражениях для решения таких проблем придумали "захватывающие" (possessive) квантификаторы,
которые такие же как жадные, но не делают возврат (то есть, по сути, они даже проще, чем жадные).

Также есть «атомарные скобочные группы» – средство, запрещающее возврат внутри скобок.

К сожалению, в JavaScript они не поддерживаются, но есть другое средство.

* ОПЕРЕЖАЮЩИЕ ПРОВЕРКИ ПРИ ПРОБЛЕМАХ С ЖАДНЫМИ КВАНТИФИКАТОРАМИ:
Исключить возврат можно с помощью опережающей проверки.

Шаблон, захватывающий максимальное количество повторений символов \w
без возврата, выглядит так: 
regexp = /(?=(\w+))\1/

Расшифровываем его:
1) Опережающая проверка на максимальное число символов "\w+", доступных с текущей позиции.
2) Содержимое скобок ВОКРУГ проверки "?=()" НЕ ЗАПОМИНАЕТСЯ движком, поэтому оборачиваем "\w+"
внутри в ещё одни дополнительные скобки
3) Далее в шаблоне мы ссылаемся на скобочную группу из пунтка 2.

То бишь мы смотрим вперёд и если там есть какое-то слово - ищем его же.

Опережающая проверка находит слово целиком и мы захватываем его в шаблон с помощью обратной ссылки
на скобочную группу. Это, по сути, захватывающий квантификатор "+".
Такой шаблон захватывает только слово целиком, а не его часть.

# Пример:
{
    alert( "JavaScript".match(/\w+Script/)); //# JavaScript
    alert( "JavaScript".match(/(?=(\w+))\1Script/)); //# null
}

В первом варианте \w+ захватывает всё слово "JavaScript", а потом квантификатор "+"
отступает назад, чтобы найти оставшуюся часть шаблона. В итоге он находит
и "Java" как соответствующее части шаблона (\w+) выражение.

Во втором варианте опережающая проверка видит сразу всё слово "JavaScript", которое 
сразу же захватывается с помощью "\1" в совпадение. Слово Script найти в таком совпадении
не удаётся, остюда получаем "null".

* ИТОГИ:
Перепишем исходный пример:
{
    let regexp = /^((?=(\w+))\2\s?)*$/;
    alert( regexp.test("A good string") ); //# Работает, true
    let str = "An input string that takes a long time or even makes this regex to hang!";
    alert( regexp.test(str) ); //# Работает, не зависает, false
}

Внутри скобок здесь \2, а не \1, ведь есть ещё одни внешние скобки.
В принципе, чтобы избежать путаницы можно просто дать скобочной группе имя:
{
    //# скобки названы ?<word>, ссылка на них \k<word>
    let regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;
    let str = "An input string that takes a long time or even makes this regex to hang!";
    alert( regexp.test(str) ); //# false
    alert( regexp.test("A correct string") ); //# true
}

"Катастрофическим возвратом" называют проблему, которую мы рассматривали в этой статье.

Решений для неё в JS на данный момент всего 2:

- Уменьшение возможных комбинаций переписыванием шаблона.
- Запрет возврата с помощью опережающих проверок.