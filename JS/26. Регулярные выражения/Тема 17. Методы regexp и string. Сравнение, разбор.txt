* МЕТОД str.match(regexp)
Метод str.match(regexp) ищет совпадения с regexp в строке str.

Имеет 3 режима работы:
1. Без флага g:
    Без флага "g" - возвращается первое совпадение в виде массива со скобочными
    группами и свойствами "index" - позиция совпадения, "input" - входящая строка str:
    {
        let str = "I love JavaScript";

        let result = str.match(/Java(Script)/);

        alert( result[0] );     //# JavaScript (всё совпадение)
        alert( result[1] );     //# Script (первые скобки)
        alert( result.length ); //# 2

        //# Дополнительная информация:
        alert( result.index );  //# 7 (позиция совпадения)
        alert( result.input );  //# I love JavaScript (исходная строка)
    }

2. С флагом g:
    Если флаг "g" есть - возвращается массив всех совпадений. Скобочных групп
    и каких-либо дополнительных деталей мы в массиве результатов не найдём.
    {
        let str = "I love JavaScript";

        let result = str.match(/Java(Script)/g);

        alert( result[0] ); //# JavaScript
        alert( result[1] ); //# undefined - скобочные группы игнорируются.
        alert( result.length ); //# 1

        //# Дополнительной информации НЕТ:
        alert( result.index ); //# undefined
        alert( result.input ); //# undefined
    }

3. Без совпадений (независимо от наличия флага g):
    Если совпадений нет - получаем "null". Важно помнить, что при отсутствии совпадений
    мы получаем не пустой массив, а именно "null". Если не помнить этого - легко допустить ошибку:
    {
        let str = "I love JavaScript";
        let result = str.match(/HTML/);

        alert(result); //# null
        alert(result.length); //# Ошибка: у null нет свойства length
    }

    Хотим обязательно получить пустой массив? Тогда хитрим и пишем так:
        let result = str.match(regexp) || [];

* МЕТОД str.matchAll(regexp)
Стоит помнить, что это - относительно новая возможность, может понадобиться "полифил".

Метод "str.matchAll" - улучшенный вариант метода "str.match".

Используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.
У него 3 отличия от match:
- Возвращает перебираемый объект с результатами. Массив можно сделать через Array.from;
- Каждое совпадение возвращается в виде массива со скобочными группами (как str.match без флага g);
- Если совпадений нет - возвращается пустой перебираемый объект, а не null.

Пример использования:
{
    let str = '<h1>Hello, world!</h1>';
    let regexp = /<(.*?)>/g;
    let matchAll = str.matchAll(regexp);

    alert(matchAll); //# [object RegExp String Iterator], не массив, а перебираемый объект

    matchAll = Array.from(matchAll); //# А вот теперь массив.

    let firstMatch = matchAll[0];
    alert( firstMatch[0] );     //# <h1>
    alert( firstMatch[1] );     //# h1
    alert( firstMatch.index );  //# 0
    alert( firstMatch.input );  //# <h1>Hello, world!</h1>
}

Если мы собираемся перебирать результаты matchAll в цикле for..of - вызов Array.from, разумеется, не нужен.

* МЕТОД str.split(regexp|substr,limit)
Разбивает строку в массив по разделителям. Разделителем может быть и регулярное выражение, и 
некая подстрока substr.

Примеры использования split со стророй и регуляркой:
{
    alert('12-34-56'.split('-'))        //# массив [12, 34, 56]
    alert('12, 34, 56'.split(/,\s*/))   //# массив [12, 34, 56]
}

* МЕТОД str.search(regexp)
Метод str.search(regexp) возвращает позицию первого совпадения с regexp в строке str.
Если совпадений нет - вернётся "-1".
    {
        let str = "Я люблю JavaScript! Хотя и Java неплох...";
        let regexp = /Java.*?/g;

        alert( str.search(regexp) ); //# 8 - позиция первого совпадения.
        alert( str.match(regexp) );  //# [ 'Java', 'Java' ]
    }

str.search способен возвращать только позицию ПЕРВОГО совпадения.
Если нужны все позиции совпадений - стоит использовать метод "str.matchAll".

* МЕТОД str.replace(str|regexp, str|func)
Это - универсальный метод поиска-замены, крайне полезный. 
Этакий швейцарский нож поиска/замены в строке.

1. Первый аргумент - строка или регулярное выражение.
Его можно использовать без регулярных выражений:
alert('12-34-56'.replace("-", ":")) //# 12:34-56 - заменился только первый дефис

Это - проблема данного метода. Когда ПЕРВЫЙ аргумент str - строка, то заменяется ТОЛЬКО 
ПЕРВОЕ СОВПАДЕНИЕ.

Если мы хотим заменить ВСЕ совпадения - вместо строки стоит использовать регулярку с флагом "g":
alert( '12-34-56'.replace( /-/g, ":" ))  //# 12:34:56 - вот так заменили все дефисы.

2. Второй аргумент - строка или функция для замены.
В ней можно использовать спецсимволы:
$& 	        вставляет всё найденное совпадение;
$` 	        вставляет часть строки до совпадения
$' 	        вставляет часть строки после совпадения
$n 	        если n это 1-2 значное число, то вставляет содержимое n-й скобки (см. главу Скобочные группы)
$<name> 	вставляет содержимое скобочной группы с указанным name (см. главу Скобочные группы)
$$ 	        вставляет "$"

Пример:
{ 
    let str = "John Smith";

    //# Меняем местами имя и фамилию:
    alert(str.replace(/(\w+) (\w+)/i, '$2, $1')) //# Smith, John
}

Для сложных ситуаций второй аргумент может быть функция.
Она будет вызываться для каждого совпадения. Её результат и будет использован как источник
для замены.

Функция вызывается с аргументами func(match, p1, p2, ..., pn, offset, input, groups):

    match – найденное совпадение,
    p1, p2, ..., pn – содержимое скобок (см. главу Скобочные группы).
    offset – позиция, на которой найдено совпадение,
    input – исходная строка,
    groups – объект с содержимым именованных скобок (см. главу Скобочные группы).

Если в регулярке скобок нет - аргумента будет 3: func(match, offset, input).

# Например, переведём найденные совпадения в верхний регистр:
{
    let str = "html and css";
    let result = str.replace(/html|css/gi, str => str.toUpperCase());
    alert(result); //# HTML and CSS 
}

# Или заменим каждое совпадение на его позицию в строке:
{
    alert("Хо-Хо-хо".replace(/хо/gi, (match, offset) => offset)); // 0-3-6
}

А здесь две скобки, поэтому функция замены вызывается с 5-ю аргументами:
первый – всё совпадение, затем два аргумента содержимое скобок, затем
(в примере не используются) индекс совпадения и исходная строка:
{
    let str = "John Smith";
    let result = str.replace(/(\w+) (\w+)/, (match, name, surname) => `${surname}, ${name}`);
    alert(result); //# Smith, John
}

Если в регулярном выражении много скобочных групп, то бывает удобно использовать
остаточные аргументы для обращения к ним:
{
    let str = "John Smith";
    let result = str.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`);
    alert(result); //# Smith, John
}

Или, если мы используем именованные группы, то объект groups с ними всегда идёт последним,
так что можно получить его так:
{
    let str = "John Smith";

    let result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
    let groups = match.pop();
    return `${groups.surname}, ${groups.name}`;
    });

    alert(result); //# Smith, John
}

Использование функций даёт нам максимальные возможности для замены, потому что функции
могут получить всю информацию о совпадениях, имеет доступ ко внешним переменным и может 
делать ещё очень много чего полезного.

* МЕТОД regexp.exec(str)
Метод regexp.exec(str) ищет совпадение с regexp в строке str. В отличие от предыдущих методов,
вызывается он на самом регулярном выражении, а не на строке.

Ведёт себя по разному, в зависимости от наличия флага "g".

"g" нет? Возвращает первое совпадение, прямо как str.match(regexp).

Если флаг "g" есть:
1) Вызов regexp.exec(str) возвращает первое совпадение и запоминает позицию после него
в свойстве regexp.lastIndex.
2) Следующий такой вызов начинает поиск с позиции regexp.lastIndex, возвращает следующее
совпадение и запоминает позицию после него в regexp.lastIndex.
3) Если совпадений больше нет, то regexp.exec возвращает null, а для regexp.lastIndex
устанавливается значение 0.

Т.О. повторные вызовы возвращают одно за другим все совпадения, а текущая позиция поиска 
отслеживается с помощью свойства "regexp.lastIndex".

Кстати, раньше вызов "regexp.exec" использовали вместо "str.matchAll" для получения
всех совпадений с их позициями и группами скобок в цикле.
# Вот пример:
{
    let str = 'Больше о JavaScript на https://javascript.info';
    let regexp = /javascript/ig;
    let result;

    while (result = regexp.exec(str)) {
        alert( `Найдено ${result[0]} на позиции ${result.index}` );
    //# Найдено JavaScript на позиции 9, а затем javascript на позиции 31
    }
}
Это сработает и сейчас, хотя "str.matchAll" разительно удобнее.

Мы можем использовать "regexp.exec" для поиска совпадения, начиная с нужной позиции, 
если сами вручную поставим значение для "lastIndex".
# Пример:
{
    let str = 'Hello, world!';
    let regexp = /\w+/g; //# Без флага g свойство lastIndex проигнорируется
    regexp.lastIndex = 5; //# Ищем с 5-й позиции (с запятой и далее)

    alert( regexp.exec(str) ); //# world
}

Для "regexp.exec" доступно использование флага "y". При его использовании
поиск будет вестись с позиции "regexp.lastIndex" и ТОЛЬКО на этйо позиции.
# Пример:
{
    let str = 'Hello, world!';
    let regexp = /\w+/y;
    regexp.lastIndex = 5; //# ищем РОВНО на 5-й позиции

    alert( regexp.exec(str) ); //# null, здесь у нас запятая.
}

* МЕТОД regexp.test(str)
Метод regexp.test(str) тоже ищет совпадение, но возвращает "true" или "false",
в зависимости от того, нашлось ли это совпадение вообще.

# Пример с true:
{
    let str = "Я люблю JavaScript";

    //# эти два теста делают одно и то же
    alert( /люблю/i.test(str) ); //# true
    alert( str.search(/люблю/i) == -1 ); //# false
}

# Пример с false:
{
    let str = "Ля-ля-ля";

    alert( /люблю/i.test(str) ); //# false
    alert( str.search(/люблю/i) == -1 ); //# true
}

Если регулярное выражение имеет флаг "g", то regexp.test ищет, начиная с "regexp.lastIndex"
и обновляет это свойство, аналогично regexp.exec.

Т.О., мы можем использовать его для поиска с заданной позиции:
{
    let regexp = /люблю/gi;
    let str = "Я люблю JavaScript";

    //# начнём поиск с 10-й позиции:
    regexp.lastIndex = 10;
    alert( regexp.test(str) ); //# false (совпадений нет)
}

Выходит, что использование одного и того же регулярного выражения несколько раз подряд
может дать разные езультаты:
{
    let regexp = /javascript/g;  // (regexp только что создан: regexp.lastIndex=0)

    alert( regexp.test("javascript") ); //# true, теперь regexp.lastIndex=10
    alert( regexp.test("javascript") ); //# false, т.к. поиск начался с позиции 10.
}

Чтобы обойти такую ситуацию стороной стоит перед новым поиском обнулить свойство
"regexp.lastIndex". Либо вместо методов на регулярном выражении вызывать метод строк 
str.match/search/... Они не используют свойство lastIndex, поэтому подобной проблемы
не будет.