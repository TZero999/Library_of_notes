В JavaScript они записываются так:

Больше/меньше: a > b, a < b.
Больше/меньше или равно: a >= b, a <= b.
Равно: a == b. Один знак равенства a = b означал бы присваивание.
Не равно в JavaScript записывается как a != b.

Все операторы сравнения возвращают значение логического типа:
true или false

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок. Сравнение происходит посимвольно.

alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true

Алгоритм сравнения двух строк довольно прост:

Сначала сравниваются первые символы строк.
Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
Сравнение продолжается, пока не закончится одна из строк.
Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

В JS испотзуется кодировка Unicode. Так, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему?
Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript.

Сравнение разных типов:
При сравнении значений разных типов JavaScript приводит каждое из них к числу. Так alert( '2' > 1 ); // true.
Логическое значение true становится 1, а false – 0.

Ещё есть операторы строгого равенства (и неравнества тоже). Это операторы === и !==
Так, например:
alert( 0 == false ); // true
alert( '' == false ); // true, т.к. пустое место преобразуется в число вместе с false. Выходит, что 0 сравнивается с 0.
alert( 0 === false ); // false, так как сравниваются разные типы.

Есть проблемы и при сравнении undefined с null:
alert( null === undefined ); // false - т.к. имеют различные типы.
alert( null == undefined ); // true - Специальное правило языка! Выходит, что эти значения равны друг другу и больше не равны никаким другим значениям.

При использовании математических операторов и других операторов сравнения < > <= >=
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.


