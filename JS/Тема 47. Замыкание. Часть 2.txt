- Вложенные функции.
Функция называется вложенной, когда она создаётся внутри другой функции.
В JS это легко реализовать:
sayHiAndBye('John', 'Smith')
    function sayHiAndBy(firstname, lastname) {
        function getFullName() {
            return firstname + ' ' + lastname;
        }
    alert ('Hello, ' + getFullName() );
    alert ('Bye, ' + getFullName() );
}

Здесь вложенная функция getFullName() создана для удобства.
Она может получить доступ ко внешним переменным и вывести полное имя.
В JS вложенные функции используются очень часто.

Вложенная функция может быть возвращена:
Либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами),
либо сама по себе.

Затем эта функция может быть использована где угодно.
Не важно где, она будет иметь доступ к тем же переменным.

Пример (вложенная функция присваивается новому объекту в конструкторе):
    function User(name) {
        this.sayHi = function() { //# Методом объекта стала вложенная функция.
            alert( name);
        };
    }
let user = new User('John');
user.sayHi(); //# у кода метода sayHi есть доступ к внешней переменной "name".

Ещё один пример - создаём и возвращаем функцию "счётчик":
    function makeCounter() {
        let count = 0;
        return function() {
            return count++;
        };
    }
let counter = makeCounter();
alert( counter() );//# 0
alert( counter() );//# 1
alert( counter() );//# 2

Визуально код прост, однако слегка модифицированные варианты этого кода применяются на практике.

Как это работает изнутри?
Когда вложенная функция начинает выполняться - начинается поиск переменной count++ изнутри-наружу.
Порядок будет такой:
1) Локальные переменные вложенной функции
2) Переменные внешней функции
3) Далее до глобальных переменных.

В примере countне определён в локальных переменных вложенной функции.
Она будет найдена во втором шаге - среди переменных внешней функции.
Т.О. count++ найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит.

Теперь 2 вопроса:
1) Мы можем сбросить счётчик count из кода вне функции makeCounter()?
2) Если makeCounter() вызывается несколько раз - нам возвращается множество функций counter().
Они независимы или работают с одной и той же переменной count?

Ответы:
1) Нет. Count - локальная переменная функции, мы не получим к ней доступ извне.
2) Count-ы независимы. Каждый вызов makeCounter() создаёт новое лексическое окружение со своим собственным count.

- Лексическое окружение шаг за шагом
Рассмотрим пошагово всё происходящее с кодом выше:
1) В момент запуска скрипта существует только глобальное лексическое значение.
В нём есть только функция makeCounter(), т.к. она объявлена через Function Declaration.

ВСЕ ФУНКЦИИ ПРИ ИХ "РОЖДЕНИИ" ПОЛУЧАЮТ СКРЫТОЕ СВОЙСТВО [[ENVIRONMENT]].
Оно ссылается на глобальное оеружение места, где они были созданы.
Благодаря этому функции знают, где они были созданы.

В нашем случае функция makeCounter() была создана в глоабльном лексическом окружении.
Поэтому свойство [[ENVIRONMENT]] будет ссылаться на него.

ФУНКЦИЯ ВСЕГДА ЗАПОМИНАЕТ ССЫЛКУ НА ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ, В КОТОРОМ ОНА БЫЛА СОЗДАНА.

2) Появляется глобальная переменная counter. Ей присваивается результат вызова makeCounter().

Когда происходит вызов makeCounter() создаётся её внутреннее лексическое окружение для хранения переменных и аргументов.
Она, как и все лексические окружения, содержит Environment Record и ссылку на внешнее окружение, которая устанавливается в значение [[ENVIRONMENT]].

В нашем случае в Environment Record хранится переменная count.
В [[ENVIRONMENT]] - ссылка на глобальное лексическое окружение.

3) В процессе выполнения makeCounter() создаётся небольшая вложенная функция, не имеющая имени.

Здесь способ объявления функции не важен. У неё иоже есть [[ENVIRONMENT]], с ссылкой на место её создания.
Так, для неё значением [[ENVIRONMENT]] будет являться ссылка на лексическое окружение функции makeCounter().

Но на этом шаге функция только была создана, ОНА ЕЩЁ НЕ ВЫПОЛНЯЕТСЯ, код {return count++} не запущен.

4) Вызов makeCounter() завешается и результат (сама вложенная безымянная функция) присваивается глобальной переменной counter.
В нашей маленькой вложенной функции есть только строка "return count++", которая будет выполнена, когда мы вызовем функцию.

5) Вызываем counter(). Создаётся новое лексическое окружение.
Оно - ПУСТОЕ! Пустое потому, что в самом counter() нет локальных переменных.
Но [[ENVIRONMENT]] counter()-а ссылается на внешнее лексическое окружение, которое даёт доступ к переменным
предшествующего ей вызова makeCounter(), где был создан counter().

Теперь вызов counter() ищет переменную count. Сначала - в своём лексическом окружении.
В Environment Record функции counter() ничего нет. С помощь [[ENVIRONMENT]] поиск продолжается в 
лексическом окружении предшествующего вызова функции makeCounter(). 
В нём counter() находит переменную count.

makeCounter() вроде бы закончил свою работу. Но его лексическое окружение остаётся в памяти, 
т.к. есть вложенная функция с [[ENVIRONMENT]], ссылающимся на него.

6) Вызов counter() не только возвращает значение count, но и увеличивает его.
Модификация происходит "на месте" - значение count меняется в том окружении, где оно было обнаружено - функции makeCounter().

7) Следующие вызовы counter() делают то же самое.

- Ответ на второй вопрос: Pete
Функция work() получает name из того места, где она была создана,
через ссылку на внешнее лексическое окружение.
    function makeWorker() {
        let name = 'Pete';
        return function() {
            alert( name);
            };
    }
let name = 'John';
let work = makeWorker();
work(); //# Pete

Если бы в makeWorker() не было "let name = 'Pete'" - поиск по лексическим окружения привёл бы функцию к глоабльному окружению.
А уже из глоабльного окружения была бы взята переменная name = 'John'.

- Замыкания
Общие термин программирования "замыкание" должен знать каждый разработчик.

Замыкание - функция, которая запоминает свои внешние переменные и может получить к ним доступ.
Говоря иначе, замыкание - это когда одна функция возвращает как результат своей работы другую функцию.
Суть заключается в том, что вложенная функция имеет доступ к переменным из внешней функции и может работать с ними в любой момент.

В некоторых языках это невозможно или функцию надо писать определённым специфическим образом.

В JS все функции изначально являются замыканиями (есть лишь одно исключение "new Function", о нём - позже).

Т.О. функции автоматически запоминают, где были созданы с помощью скрытого свойства [[ENVIRONMENT]] и 
все они могут получить доступ ко внешним переменным.

Таким образом говоря о замыкании надо дать ему определение, вспомнить, что в JS все функии являются замыканиями и напомнить о
[[ENVIRONMENT]] и работе лексического окружения.