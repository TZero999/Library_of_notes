В программировании часто получается следующая ситуация:

1: Есть «создающий» код, который делает что-то, что занимает время (например, загружает данные по сети).

2: Есть «потребляющий» код, который хочет получить результат «создающего» кода,
как только он будет готов. Он может быть необходим более чем одной функции.

3: Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JS,
который связывает «создающий» и «потребляющий» коды вместе.
«Создающий» код может выполняться сколько потребуется, чтобы получить результат,
а промис делает результат доступным для «потребляющего» кода как только он будет готов.

# Синтаксис и принцип работы промисов
{
Синтаксис промиса:
    let promise = new Promise(function(resolve, reject) {
    # функция-исполнитель (executor)
    });

Внутрь промиса передаётся функция-исполнитель. Когда промис создаётся - она запускается автоматически.
Она содержит «создающий» код, который в какой-то момент выдаст результат.

Аргументы промиса - "resolve" и "reject" - это колбэки, которые представляет нам сам JavaScript.
Наш код - только внутри исполнителя.

Как только результат исполняющей функции будет готов - он будет передан в один из этих колбэков:
"Success?" - Исполнитель выполнился успешно? : в resolve(value).
"Fault?" - Произошла ошибка при выполнении исполнителя? : в reject(error).
}

# Внутренние свойства Promise 
{
У объекта promise, возвращаемого конструктором new Promise,
есть ещё и внутренние свойства:

1: "State" («состояние») — сначала = "pending" («ожидание»).
Затем меняется на "fulfilled" («выполнено успешно») при вызове resolve,
или на "rejected" («выполнено с ошибкой») при вызове reject.

3: "Result" («результат») — сначала undefined.
Далее изменяется на value при вызове resolve(value),
или на error при вызове reject(error).
}

Пример простейшего промиса:
  let promise = new Promise(function(resolve, reject) {
    # эта функция выполнится автоматически, при вызове new Promise
    # и через 1 секунду сигнализирует, что задача выполнена с результатом "done"
    setTimeout(() => resolve("done"), 1000);
});

# Либо результат, либо ошибка:
Исполнитель должен вызвать что-то одно: resolve или reject.
Состояние промиса может быть изменено ТОЛЬКО раз.
Все последующие вызовы resolve и reject будут проигнорированы. 

# Вызывайте reject с объектом Error
В случае, если что-то пошло не так, мы должны вызвать reject.
Это можно сделать с аргументом любого типа (как и resolve).
Ео рекомендуется использовать объект Error (или унаследованный от него).
Почему так? Скоро нам станет понятно.

# Свойства state и result – внутренние
Свойства state и result – это внутренние свойства объекта Promise. 
Мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы:
".then", ".catch" и ".finally", про них речь пойдёт дальше.

