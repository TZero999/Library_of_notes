«async/await» - специальный синтаксис для работы с промисами, который называется.
Он удивительно прост для понимания и использования.

# Асинхронные функции: Async
{
Начнём с ключевого слова async.
Оно ставится перед функцией, вот так:
  async function f() {
  return 1;
}

У слова async один простой смысл - эта функция всегда возвращает промис.
Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:
  async function f() {
    return 1;
  }
f().then(alert); # 1

Как видно из примера, асинхронная функция обладает методами-обработчиками.

А ещё можно явно вернуть промис - разницы не будет:
  async function f() {
    return Promise.resolve(1);
  }
f().then(alert); # 1

Ключевое слово async перед функцией гарантирует,
что эта функция в любом случае вернёт промис.

Достаточно просто? Но это ещё не всё.
Есть и другое ключевое слово – await. Оно может использоваться только внутри async-функций.
}

#Асинхронная функция: Await
{
Синтаксис:
let value = await promise; # Работает только внутри async–функций!!!

Это ключевое слово заставит интерпретатор JavaScript ждать до тех пор,
пока промис справа от await (в нашем случае "promise") не будет выполнен.
После оно вернёт его результат, и выполнение кода продолжится.

# Пример использования await:
В этом примере промис успешно выполнится через 1 секунду:
  async function f() {
    let promise = new Promise((resolve, reject) => {
      setTimeout(() => resolve("Готово!"), 1000)
    });
     let result = await promise; # (*), код будет ждать, пока промис не выполнится 
      alert(result); # "Готово!"
  }
f();

В данном примере выполнение функции остановится на строке (*) до тех пор,
пока промис не выполнится. Это произойдёт через секунду после запуска функции.

После чего в переменную result будет записан результат выполнения промиса,
и браузер отобразит alert-окно «готово!».
}

# Пример на получение аватара с Github с помощью Async и Await:
{
    async function showAvatar() {

        # запрашиваем JSON с данными пользователя
        let response = await fetch('/article/promise-chaining/user.json');
        let user = await response.json();
      
        # запрашиваем информацию об этом пользователе из github
        let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
        let githubUser = await githubResponse.json();
      
        # отображаем аватар пользователя
        let img = document.createElement('img');
        img.src = githubUser.avatar_url;
        img.className = "promise-avatar-example";
        document.body.append(img);
      
        # ждём 3 секунды и затем скрываем аватар
        await new Promise((resolve, reject) => setTimeout(resolve, 3000));
      
        img.remove();
        return githubUser;
    }
    showAvatar();
}

Await нельзя использовать на верхнем уровне вложенности!
Это связано с тем, что await может быть использован только внутри асинхронной функции.

Пример:
# SyntaxError при await на верхнем уровне вложенности
let response = await fetch('/article/promise-chaining/user.json');
let user = await response.json();

Но систему можно обмануть, завернув этот код в анонимную асинхронную функцию:
  (async () => {
    let response = await fetch('/article/promise-chaining/user.json');
    let user = await response.json();
    ...
  })
();

# Async/ await отлично работает c Promise.all

# ИТОГО:
{
Ключевое слово async перед объявлением функции:
    1: Обязывает её всегда возвращать промис.
    2: Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:
    1: Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
    2: Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода.
Такой код легко и писать, и читать.

Хотя при работе с async/await можно обходиться без promise.then/catch,
иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например).

Также await отлично работает в сочетании с Promise.all,
если необходимо выполнить несколько задач параллельно.
}