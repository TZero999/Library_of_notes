# Fetch - промис для запросов по сети
Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети.

Давайте рассмотрим один такой пример.
Мы будем использовать метод "fetch", чтобы подгрузить информацию о пользователях с удалённого сервера.
Этот метод имеет много опциональных параметров, они разобранны в соответствующих разделах.

Но базовый синтаксис fetch весьма прост:
let promise = fetch(url);

Этот код запрашивает по сети url и возвращает промис.
Промис успешно выполняется и в свою очередь возвращает объект response после того,
как удалённый сервер присылает заголовки ответа.
Но ДО того, как весь ответ сервера полностью загружен.

Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис,
который выполняется, когда данные ПОЛНОСТЬЮ загружены с удалённого сервера, и возвращает эти данные.

# Пример использования fetch:
{
fetch('/article/promise-chaining/user.json')
    # .then в коде ниже выполняется, когда удалённый сервер отвечает
    .then(function(response) {
    # response.text() возвращает новый промис,
    # который выполняется и возвращает полный ответ сервера,
    # когда он загрузится
    return response.text();
    })
    .then(function(text) {
    # ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
});
}

Хотя здесь больше подходит метод "response.json()", который читает данные в формате JSON.
Он больше подходит для нашего примера, так что давайте использовать его.
Для более компактной записи кода применим стрелочные функции:
{
   # то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
   fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя
}

# Используем fetch всерьёз - получим данные о пользователе Github:
{
Теперь поработаем с полученными данными о пользователе.
Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя.
Затем покажем его аватар:

  # Запрашиваем user.json
  fetch('/article/promise-chaining/user.json')
    .then(response => response.json()) # Загружаем данные в формате json
    .then(user => fetch(`https://api.github.com/users/${user.name}`)) # Делаем запрос к GitHub
    .then(response => response.json()) # Загружаем ответ в формате json
    .then(githubUser => {
      let img = document.createElement('img');
      img.src = githubUser.avatar_url;
      img.className = "promise-avatar-example";
      document.body.append(img);

      setTimeout(() => img.remove(), 3000); // (*)
      # Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
    });
}

# А что если нам надо и дальше работать с данными?
{
В коде есть одна потенциальная проблема, с которой часто сталкиваются новички:
Посмотрите на строку (*): как мы можем предпринять какие-то действия после того,
как аватар был показан и удалён?

Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё.

Чтобы сделать код расширяемым нужно возвращать ещё один промис,
который выполняется после того, как завершается показ аватара.
{
  fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise(function(resolve, reject) { # (*) Меняем эту строку
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser); # (**)
    }, 3000);
  }))
  # срабатывает через 3 секунды
  .then(githubUser => alert(`Закончили показ ${githubUser.name}`)); # Жмём окей на алерте,
  # и алерт и img пропадают.
}

То есть, обработчик .then в строке (*) будет возвращать new Promise,
который перейдёт в состояние «выполнен» только после того, как в setTimeout (**)
будет вызвана resolve(githubUser).
}

# Итог:
Если обработчик в .then (или в catch/finally, без разницы) возвращает промис,
последующие элементы цепочки ждут, пока этот промис выполнится.

огда это происходит, результат его выполнения (или ошибка) передаётся дальше.