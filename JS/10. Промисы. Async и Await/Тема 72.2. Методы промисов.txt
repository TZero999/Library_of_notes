Потребители: then, catch

Объект Promise служит связующим звеном между исполнителем («создающим» кодом) 
и функциями-потребителями («потребляющим» кодом), которые получат либо результат, либо ошибку.

Потребители регистририруются на рассылку им результата с помощью методов ".then" и ".catch".

# .then
{
then - фундаментальный метод.

Синтаксис:
  promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
);

Первый аргумент метода then - функция, что выполняется при переходе промиса в состояние "Успешно".
Второй аргумент - функция, которая выполнится при переходе промиса в состояние "Ошибка".

Пример:
  let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
  });
  
  # Resolve запустит первую функцию, переданную в .then
  promise.then(
    result => alert(result), // выведет "done!" через одну секунду
    error => alert(error) // не будет запущена
);

Если мы заинтересованы только в успешном исходе - в then можно передать только одну функцию.
}

# .catch
{
catch - нужен только для обработки ошибок. 
Вызов .catch(f) – это сокращённый, «укороченный» вариант вызова .then(null, f).

Пример:
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
    });
    #.catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); # выведет "Error: Ошибка!" спустя одну секунду
}

# .finally
{  
По аналогии с блоком finally из обычного "try {...} catch {...}",
у промисов также есть метод "finally".

promise.finally(f) = promise.then(f, f).
Смысл в том, что наша функция "f" вызовется в любом случае, независимо от результата.

Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения
после завершения предыдущих операций.

Это как уборка после вечеринки. Хорошая или плохая вышла вечеринка - прибраться всё равно придётся.

Но finally не совсем равен then. Вот 3 отличия:

1: Обработчик из finally не имеет аргументов.
  
2: Обработчик finally "пропускает" результат или ошибку дальше.
    Пример:
    new Promise((resolve, reject) => {
        setTimeout(() => resolve("value"), 2000);
    })
    .finally(() => alert("Промис завершён")) # Срабатывает первым
    .then(result => alert(result)); # Срабатывает вслед за finally.

3: Обработчик finally не должен возвращать что-то. А если и возвращает - 
  возвращаемое значение всё равно игнорируется.

Исключение: когда обработчик finally выдает ошибку. Затем эта ошибка передается
следующему обработчику вместо любого предыдущего результата.

Итог:
1: Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов).
Вместо этого этот результат передается следующему подходящему обработчику.
2: Если обработчик finally возвращает что-то, это игнорируется.
3: Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.
}

# На завершённых промисах обработчик запускается сразу:
{
Промис в состоянии ожидания?
Тогда обработчики в then/ catch/ finally будут ждать его завершения.

Может случиться ситуация, когда промис уже выполнен, а мы добавляем к нему обработчик.
Тогда эти обработчики запуцстятся немедленно.
}

