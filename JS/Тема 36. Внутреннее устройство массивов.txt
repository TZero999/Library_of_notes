- Массив = объект
Массив по природе своей - это объект. Вернее особый его подвид.
Не случайно arr[] выглядит как синтаксис доступа к свойству по ключу obj[key].
Выходит, что в качестве объекта у нас массив, а в качестве ключа - числовой индекс.

Массивы расширяют возможности объектов, так как обладают специальными методами.
Но в основе массивов всё равно лежит объект.

Поэтому в JS всего 8 типов данных и массива среди них нет.
И поэтому же с массивами можно делать всё то же, что и с объектами.
Например, массив можно скопировать:

let fruits = ["Банан"]
let arr = fruits; // копируется по ссылке
// Теперь две переменные ссылаются на один и тот же массив.
alert( arr === fruits ); // true
arr.push("Груша"); // добавляем в конец массива элемент
alert( fruits ); // Вернёт Банан, Груша в оригинальном массиве.

ОСОБЕННОСТЬ массива, которая действительно очень важна - это внутреннее представление их в JS.
Движок JS хранит элементы массива в непрерывной области оперативной памяти один за другим.
Существует множество способов оптимизации, благодаря им массивы в JS работают очень быстро.

НО вся оптимизация JS утратит эффективность, если мы начнём работать с массивом, как с обычным объектом.
Например: 

let fruits = []; // Массив.
fruits[0] = 'Проверка'; // В его начало добавляем элемент - строку "Проверка".
fruits[99999] = 5; // Добавляем элемент - число 5 в свойство с индексом 99999.
fruits.age = 25; // Создаём свойство с произвольным именем.
alert(fruits); // [ 'Проверка', <99998 empty items>, 5, age: 25 ]
// ТАК КАК ЗДЕСЬ ПОКАЗАНО ДЕЛАТЬ НЕ СТОИТ...

Все эти действия осуществимы, так как в основе массива лежат объекты.
Поэтому мы можем присвоить массиву любые свойства.
НО JS поймёт, что мы работаем с массивом и ОТКЛЮЧИТ все способы ОПТИМИЗАЦИИ.
Тогда никакой пользы от использования массива не будет.

- Как НЕ НАДО работать с массивом:

1) Добавлять нечислового свойства: arr.test = 5.
2) Создавать пустые «дыры»: arr[0]; arr[1000]; // А между ними куча пустых свойств.
3) Заполнять массив "с конца": arr[1000], arr[999] и т.д.

Желательно, чтобы массив работал с однотипными данными.
Если нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект {}.

- Работать с КОНЦОМ МАССИВА БЫСТРЕЕ, ЧЕМ С НАЧАЛОМ

Методы push/pop выполняются быстро.
Методы shift/unshift – медленно.

Почему так?
Просто удалить элемент с номером 0 - недостаточно.
Ведь нужно заново пронумеровать все остальные элементы.

Т.О. инструкция shift выполняет 3 действия:
1) удаляет элемент с индексом 0.
2) Сдвигает все элементы влево, заново нумерует их, заменив 1 на 0, 2 на 1 и т.д.
3) Обновляет свойство массива length.

Если массив большой - потребуется прилично времени на эти действия.

С "unshift" то же самое - добавление элемента приводит к сдвигу элементов вправо и увеличению их индексов.

А что с "push/pop"? Им ничего не надо перемещать. 
Так, Удаление элемента приводит с очистке индекса последнего элемента и уменьшения свойства length на 1.

Выходит, что методам "pop/push" не требует перемещения элементов - все остальные элементы остаются с теми же индексами.
Именно поэтому он выполняется очень быстро.