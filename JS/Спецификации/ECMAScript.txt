Как говорилось в предыдущей теме, ECMAScript - это встраиваемый расширяемый язык программирования, который не имеет средств ввода-вывода и 
используется как основа для построения других скриптовых языков. 
ECMAScript стандартизирован в спецификации ECMA-262.

- Примитивные типы:
ECMAScript поддерживает 5 примитивных типов данных:
1) Числовой - Number;
2) Строковый - String;
3) Логический - Boolean;
4) Нулевой - Null;
5) Неопределённый - Undefined;

Числовой тип - 64-битный формат чисел с плавающей запятой. Определён стандартом IEEE 754-2008.
Единственное отличие от стандарта - се значения Not-a-Number представляются одним значением NaN.

Составной тип данных только 1:
1) Объектный - Object.

Есть ещё 7 типов данных, которые используются исключительно для хранения промежуточных этапов вычисляемых выражений и переменных:
1) Ссылочный - Reference;
2) Списочный - List;
3) Заключительный - Completion;
4) Описатель свойств - Properly Descriptor;
5) Идентификатор свойств - Properly Identifier;
6) Лексическое окружение - Lexical Environment;
7) Запись окружения - Environment Record;

- Инструкции
В ECMAScript имеется 15 различных видов инструкций:

1) Блок:                            {[<инструкции>]}
2) Объявление переменной:           var <список объявления переменных>
3) Пустая инструкция                ;
4) Выражение                        [строка до: ∉ {{, function}] инструкция
5) Условие                          if (<инструкция>) <выражение> [else <выражение>]
6) Цикл                             do <в> while <и>, while(<и>)<в>, for(<и>;<и>;<и>) <в>, for(<в> in <и>) <в>, for(<в> of <и>) <в>
7) Продолжение                      continue [<идентификатор>]
8) Прерывание                       break [<индентификатор>]
9) Возврат                          return [<инструкция>]
10) Сочетание                       with (<инструкция>) <выражение>
11) Метка                           <идентификатор>:<выражение>
12) Выбор                           switch(<инструкция>) case <инструкция>: [<выражения>][ case <инструкция>:[<выражения>] ...]
13) Генерация исключения)           throw <инструкция>
14) Блок try                        try <блок> catch (<идентификатор>) <блок>, try <блок> finally <блок>, try <блок> catch (<идентификатор>)<блок> finally <блок>
15) Отладчик                        debugger

- Инструкции, меняющие смысл при использовании перевода строки внутри:
1) Унарный постфиксный ++
2) Унарный постфиксный --
3) Продолжение continue
4) Прерывание break
5) Возврат return
6) Генерация исключения throw

- Блоки и область видимости:
Ещё одна особенность ECMAScript от С-подобных языков: блоки образуют "область видимости".
Объявленные в блоке переменные распространаются на всю функцию, содержащую блок.

- Объявление переменных:
Переменные определяются ключевыми словами var/ let/ const. 
При объявлении переменная помещается в область видимости в зависимости от способа объявления:
var - в область видимости функции;
let и const - в область видимости блока кода.

Если переменная объявляется вне функции - она помещается в глобальную область видимости.
При создании новой переменной она приобретает значение undefined. 
Если переменная объявлена с инициализацией, инициализация происходит не в момент создания переменной, а при выполнении строки с инструкцией var:
var a = 42;
function foo() {
    alert(typeof a); //# Получим alert с undefined 
    var a = 10; //# Потому что конкретно для этой функции объявили переменную после alerta
}
foo();

При создании переменной она приобретает внутреннее свойство {DontDelete} и её невозможно удалить с помощью оператора delete.
Исключение - переменные, объявленные в контексте eval.

- Ключевые зарезервированные слова:
break;      default;    for;            new;        throw;      while;
case;       delete;     function;       return;     try;        witch.
catch;      do;         if;             switch;     typeof;
continue;   else;       in;             this;       var;
debugger;   finally;    instanceof;     throw;      void;

- Ключевые зарезервированные слова в расширениях:
class;      extends;
const;      import;
enum;       super;
export;

- Ключевые и зарезервированные слова при использовании строгого режима:
implements;     protected;
interface;      public;
let;            static;
package;        yield;
private;

- Операторы:
1) . доступ к свойству; [] доступ к свойству; () вызов функции; new создание нового объекта
2) ++ инкремент; -- декремент; - унарный минус; + унарный плюс; ^ поразрядное дополнение; ! логиечское дополнение; delete - удаление свойства;
typeof определение примитивного типа; void возврат неопределённого значения
3) * умножение; / деление; % остаток от деления; + сложение; - вычитание; + конкатенация строк
4) << сдвиг влево; >> сдвиг вправо с расширением знакового разряда; >>> сдвиг вправо с дополнением нулями
5) < меньше; <= меньше или равно; > больше; >= больше или равно; instanceof проверка типа объекта; in проверка наличия свойства
6) == проверка на равенство; != проверка на неравенство; === проверка на идентичность; !== проверка на неидентичность
7) & поразрядная конъюнкция;
8) ^ поразрядное сложение по модулю 2;
9) | поразрядная дизъюнкция;
10) && конъюнкция;
11) || дизъюнкция;
12) ?: тернарная условная операция;
13) = присваивание; *=, /=, +=, -=, <<=, >>=, >>>=, &=, ^=, |= присваивание с операцией
14) , множественное вычисление

- Арность
Арность - количество аргументов или операндов операции

Унарные: delete, void, typeof, ++, --, -, +, ^, !, new
Бинарные: ., [], (), *, /, +, -, + при конкатенации, <<, >>, >>>, <, <=, >, >=, instanceof, in, ==, !=, ===, !==, &, ^, |, &&, ||,
=, *=, /=, +=, -=, <<==, >=, >>>=, &=, ^=, |=, ,
Тернарные: ?:
Операторы без фиксированного количества операндов: ()

- Особенности операторов
ECMAScript не обладает опреатором, позволяющим проверить, относится ли свойство непосредственно к объекту или унаследовано.
Для этого есть метод hasOwnProperty(), но данный метод не является оператором, потому он может быть переписан любым другим свойством.

Оператор + - это единственный арифметический оператор в языке, который отличает строковые аргументы.
Если хотя бы один из операндов является строкой - "+" подействует как конкатенатор. Иначе будет выполнено сложение.

Есть языки, гдек void - это тип данных. В ECMAScript void - это оператор, который возвращает значение undefined.

Оператор "==" осуществляет проверку на равенство по алгоритму из 10 шагов.
В ряде случаев этот алгоритм подразумевает преобразование типов, что порой приводит к неочевидным результатам:
alert("NaN" == NaN);       // false
alert(NaN == NaN);         // false
alert(true == 1);          //# true
alert(true == 42);         // false
alert(null == 0);          // false
alert(0 == "");            //# true
alert("" == 0);            //# true
alert("false" == false);   // false
alert(false == 0);         //# true
alert(undefined == false); // false
alert(null == false);      // false
alert(undefined == null);  //# true
alert(" \t\r\n " == 0);    //# true

Поэкспериментировать можно тут: https://felix-kling.de/js-loose-comparison/

- Функции:

В ECMAScript Функции = Объекты.
Конструктор, что создаёт функции - Function().
Функции, как и любые другие объекты, могут храниться в переменных, объектах и массивах.
Так же они могут передаваться как аргументы в другие функции и могут возвращаться другими функциями.

Функции могут иметь свойства. Специфическая черта ECMAScript - функции могут быть вызваны.

- Разница в способах объявления функции:
//# Объявление функции
function sum(arg1, arg2) { return arg1 + arg2 };

//# задание функции с помощью выражения
var sum2 = function sum(arg1, arg2) { return arg1 + arg2 };

Наиболее существенной разницей между заданием функции с использованием объявления и заданием функции с помощью выражения является то,
что в первом случае создание переменной и присваивание ей в качестве значения функции осуществляются до выполнения кода
при входе в контекст исполнения.

Во втором случае переменная получает значение инициализатора при выполнении оператора присваивания.
При создании же переменной, осуществляемом при входе в контекст исполнения, она инициализируется значением undefined.

alert(sum(3, 4)); //# Получаем 7, т.к. переменная sum к моменту выполнения этой строки уже создана и в качестве значения ей присвоена функция
function sum(arg1, arg2) {
    return arg1 + arg2;
}

alert(sum2(3, 4)); //# Ошибка, т.к. переменная sum2 к моменту выполнения этой строки уже создана, но в качестве значения ей присвоено undefined
var sum2 = function(arg1, arg2) {
    return arg1 + arg2;
};

Ещё есть вариант с конструктором:
var sum3 = new Function("arg1", "arg2", "return arg1 + arg2;");
Но он менее предпочтителен, т.к. может негативно сказаться на производительности.

- Присваивание функций:

Функции = объект. Значит они относятся к ссылочному типу данных, а идентификаторы функций являются переменными, хранящими ссылку на функцию:
    var sum = function(arg1, arg2) {
    return arg1 + arg2;
    };
    alert(sum(3, 4));    // 7

    var sum2 = sum;
    alert(sum2(4, 2));   // 6

    sum = null;
alert(sum2(42, 42)); // 84

Две особенности присваивания функций:
1) Присваивание одной функции другой происходит без использования (), как в примере выше.
var sum2 = sum() присваивало бы sum2 не саму функцию, а только её результат.

2) После присваивания функции переменная sum2 указывает "клонирует" функцию, поэтому затирание переменной sum не влияет на работу функции в переменной sum2.

- Перегрузка ("перезапись") функций:
Перегрузка - это возможность использования одноимённых подпрограмм и функций.

Пример перегрузки в ECMAScript:
function sum(arg1, arg2) { return arg1 + arg2 };
function sum(arg1, arg2, arg3) { return arg1 + arg2 + arg3 };

alert(sum(3, 4));       //# NaN
alert(sum(3, 4, 5));    //# 12

Т.О., если объявлено несколько функций - более позднее объявление перезапишет ранние объявления.

Перегрузку можно осуществить, но довольно специфическими способами:
1) Сделать проверку на undefined (if (arg3 == undefined) {return arg1 + arg2})
2) Сделать проверку типа через typeof, instanceof, constructor и кастомизировать поведение функции в зависимости от типов:
switch (typeof arg3) { case "undefined": return arg1+arg2; case "number": return arg1+arg2+arg3; ... }
3) Обратиться к аргументам через объект arguments и узнать количество фактически переданных аргументов через свойство length:
for (let i=0; i < arguments.length; i++) { res += arguments[i] }

- Рекурсия
ECMAScript допускает рекурсивный вызов.
Если при задании функции не был указан идентификатор после ключевого слова function внутри функции можно будет обратиться к ней с помощью 
объекта arguments и его свойства callee:
return arguments.callee(step - 1, step * res); 

- Функции обратного вызова
В ECMAScript функция - это объект первого класса, который может быть передан как аргумент в другую функцию.
Если при этом она вызывается внутри функциии, в которую была передана - это "функция обратного вызова".

Если у этой передаваемой функциии нет имени - это "анонимная функция обратного вызова".

Причины использования функция обратного вызова:
1) Избегание именования функции при работе с ней - снижение числа глобальных переменных;
2) Делегирование вызова функции другой функции - повышение выразительности кода;
3) Увеличение быстродействия;
4) Упрощение оперирования с непродолжительными событиями.

Пример:
function sumOfResults(callback) {
    var result = 0;
    for (var i = 1; i < arguments.length; i++) {
        result += callback(arguments[i]);
    }
    return result;
}

var square = function(x) {
    return x * x;
};
alert(sumOfResults(square, 3, 4)); // 25

- Замыкание
Функциям в ECMAScript присуща лексическая область видимости.
Значит область видимости определяется в момент определения функции. 
Динамическая область видимости определяется в момент вызова функции.

Простыми словами "Замыкание" - это функция, которая ЗАПОМИНАЕТ СВОИ ВНЕШНИЕ переменные и может ПОЛУЧИТЬ К НИМ ДОСТУП.
Более сложным языком: в ECMAScript, в процессе выполнения скрипта, функции, которые обладают доступом к локальным переменным,
сохраняют этот доступ  на протяжении всего выполнения скрипта.

Замыкание используется для того, чтобы ограничить видимость переменных автономного участка скрипта. Это позволит избежать
конфликта имён при совместном использовании с другим кодом. Для этого код помещают в анонимную функцию и снабжают её оператором вызова функции.

Доступ к локальным переменным анонимной функции остаётся возможным. Извне анонимной функции доступ к ним осуществить нельзя.

- Объекты
Объекты в ECMAScript - неупорядоченные коллекции свойств, каждое из которых имеет один+ элемент, определяющий работу свойства.
Свойства = контейнеры, инкапсулирующие другие объекты, значения примитивных типов и методы.

* Атрибуты свойств объектов ECMAScript:
1) ReadOnly - только для чтения. Менять значения свойства нельзя, если не прибегнуть к расширениям языка.
2) DontEnum - свойство не перечисляется циклом for-in
3) DontDelete - свойство нельзя удалить
4) Internal - свойство является внутренним: оно не имеет названия, к нему нельзя получить доступ с помощью аксессоров

- Объекты ECMAScript подразделяются на базовые (native) и расширенные (host).
Базовые (стандартные) - любые объекты, независимые от окружения, относящегося к расширению самого языка.
Некоторые из базовых объектов являются встроенными (built-in) - они существуют с самого начала работы скрипта.
Другие могут быть созданы при выполнении скрипта.

Объекты расширения - для ECMAScript объекты расширения - это объекты  браузера (например, window -глобальный объект и окно браузера одновременно).

* Синтаксис объявления объектов
Существует объектная и литеральная форма объявления объекта:
var obj1 = new Object(); - объектная форма
var obj2 = new Object; - объектная форма
var obj3 = {}; - литеральная форма
Первых двух вариантов рекомендуют избегать.

Каждый объект в языке имеет следующие свойства:
1) constructor - функция для создания объекта ;
2) hasOwnProperty(propertyName) - показывает, существует ли данное свойство в объекте;
3) isPrototypeOf(object) - определяет, находится ли объект в цепи прототипов объекта-аргумента;
4) propertyIsEnumerable(propertyName) - показывает, является ли свойство с данным названием перечисляемым в цикле for-in;
5) toString() - возвращает представление объекта в виде строки;
6) valueOf() - Возвращает значение this. Если объект - результат вызова конструктора - значение зависит от реализации.

- Подходы к созданию объектов:
1) Фабрика объектов - функция, создающая объекты и возвращающая их в качестве своего значения;
2) Конструктор - функция, использующая слово this для формирования свойств объекта, создаваемого ей же с помощью оператора "new";
3) Прототипный подход - задействование свойства prototype функции для вынесения общих свойств объектов;
4) Метод паразитического конструктора - использование new с функцией фабрики объектов;

- Классы
Классы - это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию.
Более простыми словами: Класс - это шаблон кода, по которому создаются объекты.

КЛАССОВ в языке НЕТ, но их можно сэмулировать за счёт использования конструкторов.

Пример эмуляции классов:
function MyClass() {
    this.myValue1 = 1;
    this.myValue2 = 2;
}

MyClass.prototype.myMethod = function() {
    return this.myValue1 * this.myValue2;
}

var mc      = new MyClass();
mc.myValue1 = mc.myValue2 * 2;
var i       = mc.myMethod();

- Особенности наследования в ECMAScript
Для каждой составляющей объекта можно расмотреть наследование.
В ECMAScript не существует наследлования интерфесов (потомок наследует интерфейс, но не функциональность).