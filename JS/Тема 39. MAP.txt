Существует 2 сложнеы структуры данных:

1) Объекты для хранения именованных коллекцией;
2) Массивы для хранения упорядоченных коллекций.

Но их не всегда хватает, для решения повседневных задач.
Поэтому существуют Map и Set.

- MAP

Map - коллекция ключ/ значение, как и у обычного объекта.
Разница - Map позволяет использовать КЛЮЧИ ЛЮБОГО ТИПА.

"Методы и свойства Map":
1) new Map() - создаёт коллекцию;
2) map.set(key, value) - записывает по ключу key значение value;
3) map.get(key) - возвращает значение по ключу (или undefined, если такого ключа нет);
4) map.has(key) - возвращает true, если такой ключ есть (или false);
5) map.delete(key) - удаляет элемент по ключу key;
6) map.clear() - очищает коллекцию от всех элементов;
7) map.size  - возвращает текущее количество элементов.

Пример:
 let map = new Map();
 map.set ('1','str1');    //# Ключ - строка
 map.set (true, 'bool1'); //# Ключ - булево значение
 map.set (1, 'num1');     //# Ключ - цифра

 alert(map.get(1));       //# 'num1'
 alert(map.get('1'));     //# 'str1'
 alert (map.size);        //# 3
 alert (map.has(1));      //# true
 map.delete(true); 
 alert (map.size);        //# 2
 alert (map);             //# Map { '1' => 'str1', 1 => 'num1' }

В итоге ключи не были приведены к строкам и мы смогли использовать любые типы данных.

"Предупреждение:"
Не стоит использовать map[key]. Это сработает, мы сможем установить, например, map[key] = 2.
Но тогда map бужет рассматриваться JS как обычный объект, что приведёт к ограничениям на типы (ключ - только строка/символ).
Поэтому следует дейстовать с Map строго используя методы, приведённые выше.

- Map и объекты в качестве ключей

    let john = { name: "John" };        //# Посетитель
    let visitsCountMap = new Map();     //# Коллекция, где будем хранить количество посещений 
  
    visitsCountMap.set(john, 123);      //# Используем объект как ключ, добавляем ему значение.
alert(visitsCountMap.get(john));    //# 123

Это - одна из наиболее ВАЖНЫХ функций Map.
Это то, что невозможно сделать с Object.

Если попытаемся использовать Object в качестве ключа для Object - получим:

    let john = { name: "John" };    //# Посетитель 1
    let ben = { name: "Ben" };      //# Посетитель 2
    let visitsCountObj = {};        //# И пустой объект, который будем использовать как ключ

    visitsCountObj[ben] = 234;      //# Используем объект ben как ключ
    visitsCountObj[john] = 123;     //# Используем объект john как ключ. Объект ben будет замещён.
alert(visitsCountObj);              //# { '[object Object]': 123 } - то, что на самом деле хранится в объекте.

Т.О. если используем любой объект как ключ для другого объекта - получаем одну и ту же СТРОКУ '[object Object]'.

"Сравнение ключей Map"
Map для сравнения ключей использует алгоритм "SameValueZero". 
Оно работает как ===, но в нём NaN === NaN.
Поэтому NaN тоже можно использовать в качестве ключа.

"Цепочка вызовов"

map.set("1", "str1")
   .set(1, "num1")
   .set(true, "bool1");
Можно укоротить запись set-ов, так как map.set возвращает сам объект map.

- Перебор Map

Для перебора Map есть 3 метода:
1) map.keys() - возвращает итерируемый объект по ключам;
2) map.values() - возвращает итерируемый объект по значения;
3) map.entries() - возвращает итерируемый объект по парам [ключ, значение]. Дефолт для for... of...

Пример:
    let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук",    50]
    ]);
  
    //# map.keys() - Перебор по ключам (овощи)
        for (let vegetable of recipeMap.keys()) {
        alert(vegetable); //# огурец, помидор, лук
    }
  
    //# map.values - Перебор по значениям (числа)
        for (let amount of recipeMap.values()) {
        alert(amount); //# 500, 350, 50
    }
  
    //# map.entries - Перебор по элементам в формате [ключ, значение]
        for (let entry of recipeMap.entries()) {
        alert(entry); //# [ 'огурец', 500] ['помидор', 350] и т.д.
    }
for (let entry of recipeMap) == for (let entry of recipeMap.entries())

ПЕРЕБОР происходит В ПОРЯДКЕ ДОБАВЛЕНИЯ ЭЛЕМЕНТОВ.

"Можно использовать forEach для Map:"
recipeMap.forEach((value, key, map) => {alert(key + " : " + value)}); //# огурец: 500 и так далее

- Создаём MAP из Object - Object.entries

Если у нас есть объект, но нам надо сделать из него коллекцию Map - надо использовать метод Object.entries(obj).
Он получает объект и возвращает массив пар ключ-значение.

Пример:
    let obj = {
    name: "John",
    age: 30
    };
  
    let map = new Map(Object.entries(obj));
alert( map.get('name') ); //# John

- Создаём Object из MAP - Object.fromEntries

Противоположен методу Object.entries, позволяет получить объект из массива Map.

Пример:
    let pricesMap = new Map();
    pricesMap.set ('banana', 1)
             .set ('orange', 2)
             .set ('meat', 4); 
    
    let pricesObj = Object.fromEntries(pricesMap); //# Теперь у нас есть объект pricesObj = { banana: 1, orange: 2, meat: 4 }
alert(pricesObj.orange); //# 2

Т.О. можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

Мы могли бы написать Object.fromEntries(pricesMap.entries), но это излишне.
Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив.
Перебор map как раз возвращает пары ключ/значение, так же, как и map.entries().
Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в map.