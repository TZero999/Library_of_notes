- Поиск подстроки

Существует сразу несколько способов поиска подстроки:

1) str.indexOf (substr, pos) - ищет подстроку substr в строке str начиная с позиции pos.
Возвращает этот метод позицию, на которой располагается совпадение, либо -1, если совпадений нет.
Пример:

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

В последнем случае ожидали увидеть другое? Тогда можно использовать необязательный второй аргумент pos:
let str = 'Widget with id';
alert( str.indexOf('id', 2) ) // 12

Надо найти все вхождения подстроки? Использует indexOf в цикле. Вот пример:

let str = 'Ослик Иа-Иа посмотрел на виадук';
let target = 'Иа'; // цель поиска
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}

Но можно записать и короче:

let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}

КСТАТИ, есть метод str.lastIndexOf(substr, pos)
Он ищет подстроку с конца строки к её началу.
Он используется тогда, когда нужно получить самое последнее вхождение.

- ТАКОЙ ТРЮК НЕ ПРОЙДЁТ:

let str = "Widget with id";
if (str.indexOf("Widget")) {
    alert("Совпадение есть"); // не работает, т.к. indexOf возвращает здесь 0, if решает, что это false.
}

Чтобы всё это дело заработало - надо сделать проверку на -1:

let str = "Widget with id";
if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}

- НО можно сделать и иначе: ТРЮК С ПОБИТОВЫМ НЕ!

Это старый трюк, использующий побитовый оператор НЕ - ~.
Он преобразует число в 32-разрядное целое со знаком.
Дробная часть, если она присутствует, - отбрасывается.
Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение ~n равно -(n+1).
Т.О.:

alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
alert( ~-1 ); // 0, то же, что -(-1+1)

Так, ~n равняется 0, только если n == -1.

Получается, что прохождение проверки if ( ~str.indexOf("…") ) говорит нам,
что результат indexOf отличен от -1, а значит у нас есть совпадения. 
Вот как выглядит этот трюк на примере:

let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( 'Совпадение есть' ); // работает
}

Обычно использовать возможности языка каким-либо неочевидным образом - не рекомендуется.
Но этот трюк широко используется в старом коде, поэтому его важно понимать.
Надо просто запомнить, что:

if (~str.indexOf(…)) означает «если найдено»

В современных реалиях такие трюки не нужны - есть метод .includes()

- includes, startsWith, endsWith

метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.
Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция нам не нужна:

alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") ); // false

Необязательный второй аргумент (pos) позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3

Методы str.startsWith проверяет, НАЧИНАЕТСЯ ЛИ строка определённой подстрокой.
str.endsWith проверяеь ЗАКАНЧИВАЕТСЯ ЛИ строка определённой подстрокой.
Примеры:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"