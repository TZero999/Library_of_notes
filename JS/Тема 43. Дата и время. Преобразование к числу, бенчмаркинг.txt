- Преобразование к числу и разность дат

Преобразовав дату к числу получим timestamp (по аналогии с date.getTime()):
let date = new Date();
alert(+date); //# 1664882882916 - количество миллисекунд.

При вычитании дат в результате получаем разность в миллисекундах.

Так можно, например, создать таймер:
    let start = new Date(); //# Начинаем отсчёт времени
        for (let i = 0; i < 100000; i++) {
        let doSomething = i * i * i;
    }
    let end = new Date(); //# Заканчиваем отсчёт времени
alert( `Цикл отработал за ${end - start} миллисекунд` );

- Date.now()
Есть особый метод Date.now(), возвращающий текущую метку времени.

Он эквивалентен new Date() и get.Time(), но отличается тем, что не создаёт промежуточный объект.
Таким образом он работает быстрее и не нагружает сборщик мусора.
Т.О. используется данный метод в приложениях, требующих повышенного быстродействия.

Потому предыдущий пример можно переписать вот так:
    let start = Date.now(); //# Количество миллисекунд с 1 января 1970 года
    for (let i = 0; i < 100000; i++) {
    let doSomething = i * i * i;
    }
    let end = Date.now(); //# Заканчиваем отсчёт времени
alert( `Цикл отработал за ${end - start} миллисекунд` ); //# Dычитаются числа, а не даты

- Бенчмаркинг (Тестирование производительности)
Попробуем сравнить 2 функции, производительность которых зависит от процессора.

Пример: есть date1 и date2, какая функция быстрее вернёт разницу между ними в миллисекундах?
    function diffSubtract(date1, date2) {
    return date2 - date1;
    }
//# И
    function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime();
}

Обе функции делают одно и то же, но 1 использует метод date.getTime() для получения даты в МС, 
а вторая функция полагается на преобразование даты в число.
Какую лучше использовать для приложения, требующего повышенной производительности?

Запустим обе функции 100.000 раз (так много лишь потому, что функция у нас довольно простая).
  function diffSubtract(date1, date2) {
    return date2 - date1;
  }
  
  function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime();
  }
  
  function bench(f) {
    let date1 = new Date(0);
    let date2 = new Date();
  
    let start = Date.now();
    for (let i = 0; i < 100000; i++) f(date1, date2);
    return Date.now() - start;
  }
  
alert( 'Время diffSubtract: ' + bench(diffSubtract) + 'мс' );
alert( 'Время diffGetTime: ' + bench(diffGetTime) + 'мс' );

Видим, что метод getTime() работает намного быстрее.
Преобразование типов зачастую понижает производительность кода.

Но это очень слабенький бенчмарк.
Почему? Потому как при выполнении функций bench(...) процессор мог быть занят 
ещё много чем. Причём каждый раз онмог быть загружен иными процессами по-разному.

- Улучшение нашего бенчмарка
Чтобы повысить точность бенчмарка хорошим решением является повторный запуск самих бенчмарков.

Например, вот так:
  function diffSubtract(date1, date2) {
    return date2 - date1;
  }
  
  function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime();
  }
  
  function bench(f) {
    let date1 = new Date(0);
    let date2 = new Date();
  
    let start = Date.now();
    for (let i = 0; i < 100000; i++) f(date1, date2);
    return Date.now() - start;
  }
  
  let time1 = 0;
  let time2 = 0;
  
  //# bench(diffSubtract) и bench(diffGetTime) поочерёдно запускаются 10 раз
  for (let i = 0; i < 10; i++) {
    time1 += bench(diffSubtract);
    time2 += bench(diffGetTime);
  }
  
alert( 'Итоговое время diffSubtract: ' + time1 );
alert( 'Итоговое время diffGetTime: ' + time2 );

Всё это делается не только для того, чтобы уменьшить шанс на "поимку" загруженности процессора.
Современные интерпретаторы JS начинают оптимизировать код, только когда он выполняется несколько раз.

Так, интерпретатор JS считает, что не за чем оптимизировать то, что выполняется редко.

"Не стоит увлекаться микробенчмарками"
Интерпретаторы JS выполняет много оптимизаций. Они могут влиять на результаты 
наших искусственных тестов. Особенно если работаем с чем-то маленьким (функцию или оператор).

- Разбор строки с датой
Метод Date.parse(str) способен считать дату из строки.

Формат строки должен быть таким: "YYYY-MM-DDTHH:mm:ss.sssZ", где:
1) YYYY-MM-DD - это год-месяц-день;
2) T - символ-разделитель;
3) HH:mm:ss.sss - часы, минуты, секунды и миллисекунды;
4) Z - часовой пояс в формате +-hh:mm (необяз.). Если указать просто Z - получим UTC+0.

Возможны и более короткие варианты: YYYY-MM-DD, YYYY-MM, YYYY.

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп.
Напоминаем, таймстамп - количество МС с 1 января 1970-го в формате UTC+0.
Если формат неправильный - вернётся NaN.

Пример:
  let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert(ms); // 1327611110417 (таймстамп)

Из этого таймстампа можно сразу создать объект Date:
  let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );
alert(date);

