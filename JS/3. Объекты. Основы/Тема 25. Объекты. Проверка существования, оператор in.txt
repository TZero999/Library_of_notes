Есть важная особенность JS:
Можно получить доступ к ЛЮБОМУ ОБЪЕКТУ, даже ЕСЛИ ЕГО НЕ СУЩЕСТВУЕТ. 
Если мы обращаемся к свойтсву, а его нет - получаем undefined:

let user = {};
alert( user.noSuchProperty === undefined ); // Получили true? Значит "свойства нет".

Но можно сделать куда проще, ведь есть оператор in:
"key" in object // Проверяет, есть ли свойство key в объекте object

Пример использования:
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует

СЛЕВА от in ВСЕГДА должна быть ИМЯ СВОЙСТВА

Вроде бы можно было бы всегда использовать строгое сравнение с undefined, 
зачем же ввели in?

Бывает такое, что свойство существует, но всё же не определено и имеет тип undefined.

let obj = {
    test: undefined
  };
  alert( obj.test ); //  выведет undefined, значит свойство не существует?
  alert( "test" in obj ); // true, Но свойство существует!

Однако можно использовать и строгое сравнение, так как для неопределённых значений свойств всегда используют null.

ЦИКЛ "FOR ... IN"

Для перебора всех свойств объектов используется for .. in.
Этот цикл отличается от изученного ранее for (;;).

Синтаксис:
for (key in object) {
    // тело цикла выполняется для каждого свойства объекта
}

Пример:
let user = {
    name: "John",
    age: 30,
    isAdmin: true
  };
  
  for (let key in user) {
    alert( key );  // name, age, isAdmin (список ключей)
    alert( user[key] ); // John, 30, true (значения ключей)
}

Не забываем, что все конструкции for позволяют нам объявлять переемнные внутри цикла.