Тема о том, как движок JS обнаруживает, что пора очищать память и какими способами делает это.

ДОСТИЖИМОСТЬ

Это слово олицетворяет основной принцип управления памятью в JS.
Достижимые значения - те, что доступны или используются (просто выражаясь).

1) Есть базовое множество достижимых объектов, которые НЕ могут быть УДАЛЕНЫ:
- Выполняемая в данный момент функция, её локальные переменные и параметры;
- Другие функции в текущей цепочке вложенных вызовов, их глобальные переменные и параметры;
- Глобальные переменные;
- Некоторые другие внутренни значения.

Эти базовые значения называются "Корнями".

2) Любое другое значение достижимо, если:
- Оно доступно из корня по ссылке или цепочке ссылок.

Так, если в глобальной переменной есть объект (obj1), и этот объект имеет свойство, в котором хранится ссылка на другой объект (obj2) -
этот второй объект (obj2) будет считаться достижимым. А объект (obj3), на которые будет ссылаться (obj2) - тоже достижим.

GARBAGE COLLECTOR:

В движке JS есть фоновый процесс, называемый "Сборщик мусора" (англ. garbage collector). Он отслеживает и удаляет те объекты, которые стали недоступны.
Пример:

let user = {
  name: "John"
}; // Глобальная переменная user ссылается на объект.
// Теперь перезаписываем значение переменной user.
user = null;
// Глобальная переемнная равна null, объект "name: 'John'" недостижим, но пока существует

Когда объект "name: 'John'" становится недостижимым - сборщик мусора удаляет его и освобождает память.

СБОРЩИК МУСОРА И ДВЕ ССЫЛКИ:

Тут всё просто. Есть 2 объекта:

let user = {
    name: "John"
  };
let admin = user; // передаём в admin ссылку на объект.

Теперь, если мы "затрём" одну переменную (user = null) - объект останется достижим.
Он сохранится в памяти, т.к. на него ссылается глобальная переменная "admin".\

ВЗАИМОСВЯЗАННЫЕ ОБЪЕКТЫ
Тут всё будет сложнее:

function marry(man, woman) {
    woman.husband = man;
    man.wife = woman;
  
    return {
      father: man,
      mother: woman
    }
  }
  
  let family = marry({
    name: "John"
  }, {
    name: "Ann"
});

Что мы видим здессь?
Есть функция, которая "женит" 2 объекта, давая им ссылки друг на друга. 
Возвращает эта функция ещё один объект, содержащий ссылки на 2 предыдущих.

А теперь удалим 2 ссылки:
delete family.father;
delete family.mother.husband;
// Если бы удалили только одну из них - всего нижеописанного не произошло бы:

Получаем недостижимый объект {name: 'John'}, от которого исходит ссылка к достижимому объекту {name: 'Ann'}.
Сборщик мусора очистит память от объекта {name: 'John'}, т.к. ИСХОДЯЩИЕ ССЫЛКИ НЕ ИМЕЮТ ЗНАЧЕНИЯ!

Т.О. мы убеждаемся, что ТОЛЬКО ВХОДЯЩИЕ ссылки делают объект ДОСТИЖИМЫМ.

НЕДОСТИЖИМЫЙ ОСТРОВ

Вполне вероятна ситуация, когда целый "кусок" (остров) взаимосвязанных объектов вдруг становится недостижимым.

Берём объект family (до удаления ссылок) из примера выше и "затираем" его:
family = null;
 
Входящих ссылок на "подвешенные" объекты больше нет, объекты {name: 'John'}, {name: 'Ann'} и объект, возвращаемый функцией "Marry"
становятся недостижимыми. 
Выходит, что объекты связаны, имеют входящие ссылки, но т.к. объект "family" был отсоединён от "корня"

Таким образом целые "острова" объектов могут стать недостижимыми и удалиться из памяти.

ИТОГО:

1) Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
2) Объекты сохраняются в памяти, пока они достижимы.
3) Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня):
набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.