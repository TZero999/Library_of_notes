Некоторые хитрости в вызовах метода могут приводить к потере значения this.

Вот пример:
let user = {
    name: "Джон",
    hi() { alert(this.name); },
    bye() { alert("Пока"); }
};
user.hi(); // Получим Джон (простой вызов метода работает отлично)
//А теперь давайте попробуем вызывать user.hi или user.bye в зависимости от user.name:
(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!

В последней строчке видим условный оператор "?". Он должен определять, будет ли вызван метод user.hi или user.bye
В данном случае будет выбран user.hi

Затем метод тут же вызывается скобками (). Но он не сработает, как положено.

Можно убедиться, что значение "this" внутри функции станет "undefined" (если используем строгий режим).

Получаем 2 ситуации:
1) user.hi(); // Так всё работает;
2) (user.name == "Джон" ? user.hi : user.bye)(); // А так уже нет.

Чтобы разобраться почему - анализируем работу вызовов методов (obj.method()).
У них есть 2 операции, идущие по очереди:
1) Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
2) Затем скобки вызывают этот метод - выполняют его код.

А теперь смотрим, как информация о this передаётся между частями:

let user = {
    name: "Джон",
    hi() { alert(this.name); }
};
// Разделяем получение метода объекта и его вызов:
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined

Здесь hi = user.hi сохраняет функцию в переменной.
В последней строке она вызывается полностью сама по себе. В ней нет объекта, поэтому нет и this.

ТЕПЕРЬ САМОЕ ВАЖНОЕ:

Для работы вызовов типа "user.hi()" JS использует один трюк:
Точка НЕ ВОЗВРАЩАЕТ САМУ ФУНКЦИЮ, а возвращает лишь ЗНАЧЕНИЕ ССЫЛОЧНОГО ТИПА!

Значение "ссылочного типа" называют "Reference Type".

Этот ссылочный тип - не один из 8 типов данных, так как он является "ВНУТРЕННИМ ТИПОМ" -
Мы не сможем явно использовать его. он используется "под капотом" языка.

ССЫЛОЧНЫЙ ТИП

Значение ссылочного типа - "Триплет" - комбинация из трёх значений:
- base - Объект
- name - Свойства объекта
- strict - Режим исполнения. Если используем 'use strict' это значение будет true.

Получается, что результат доступа к user.hi не сама функция, а значения ссылочного типа.
Так, для "user.hi" в строгом режиме это значение будет иметь следующий вид:

// значение ссылочного типа (Reference Type)
(user, "hi", true)

Используя пустые скобки и пытаясь вызвать метод мы вызываем вызов ссылочного типа,
получаем ПОЛНУЮ информацию об объекте и его методе (И могут правильно определить значение this = user (по base)).

Ссылочный тип - ИСКЛЮЧИТЕЛЬНО ВНУТРЕННИЙ тип.
Он ПЕРЕДАЁТ ИФНОРМАЦИЮ от ТОЧКИ до ВЫЗЫВАЮЩИХ СКОБОК.

Так, при присваивании hi = user.hi ссылочный тип здесь заменяется на собственное значение user.hi (функцию).
Дальнейшая работа происходит уже только с ней, вызов происходит уже без this.

ТАКИМ ОБРАЗОМ значение this передаётся правильно только если функция вызывается НАПРЯМУЮ -
с использованием метода obj.method() или obj['method']().

Позже мы рассматорим разные варианты решения проблемы потери значения this (func.bind() и т.д.).

- ВАЖНО:

