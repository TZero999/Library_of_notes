Обычно методу объекта необходим доступ к информации (свойствам), которая хранится в объекте.

Так, коду внутри user.sayHi() может понадобиться имя пользователя, хранящееся в объекте user.

ДЛЯ ДОСТУПА К ИНФОРМАЦИИ ВНУТРИ ОБЪЕКТА МЕТОД ИСПОЛЬЗУЕТ КЛЮЧЕВОЕ СЛОВО "THIS":

Значение this - объект "перед точкой", который использовался для вызова метода.
Пример:

let user = {
    name: "Джон",
    age: 30,
    sayHi() {
      alert(this.name);  // this - это "текущий объект"
    }
}

Выходит, что здесь во время выполнения кода user.sayHi() значением "this" будет ссылка на объект "user".

- ДЛЯ ЧЕГО ЭТО НАДО?

На первый взгляд в примере выше можно просто написать alert(user.name). Да, можно, всё будет работать.
Но надёжность такого способа под вопросом.

Например, мы скопировали объект user в другую переменную (admin = user). Переменную user перезаписываем.
Если у нас будет использован метод alert(user.name), то при вызове из объекта admin он обратится к 
неправильному, уже модифицированному объекту user.

Пример нежелательной ситуации:
let user = {
    name: "Джон",
    age: 30,
    sayHi() {
      alert( user.name ); // Использовали тут user.name вместо this.name. Смотрим дальше.
    }
};
  
let admin = user;
user = null; // обнуляем переменную. Теперь в ней нет ссылки на объект.
admin.sayHi(); // Ошибка! 

Всё произошло потому, что внутри sayHi() использовался user. А user больше не ссылается на объект.
Если заменим user.name на this.name - код заработает.

- THIS НЕ ЯВЛЯЕТСЯ ФИКСИРОВАННЫМ.

Что это значит?
В JS слово this ведёт себя иначе, чем в большинстве ЯП. Его можно использовать в любой функции:

function sayHi() {
  alert( this.name ); // Ошибки не будет.
}

Т.О. значение this вычисляется в момент выполнения кода и полностью зависит от контекста.
Пример:

let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}
// используем одну и ту же функцию в двух объектах:
user.f = sayHi;
admin.f = sayHi;
//"this" внутри функции - ссылка на объект, который указан "перед точкой":
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

- ВЫЗОВ THIS БЕЗ ОБЪЕКТА:

Подобный код:
function sayHi() {
    alert(this);
}
sayHi();

Даст нам разные результаты в строгом ('use strict') и нестрогом режиме:
1) Строгий режим 'use strict': значение this == undefined.
Вызов по типу this.name даст нам ошибку.

2) В нестрогом режиме: значение this == window (ГЛОБАЛЬНЫЙ ОБЪЕКТ БРАУЗЕРА).
Может быть и не window. К теме глобальных объектов вернёмся позже.

Вообще, подобный вызов - это, как правило, ошибка. ПОЧТИ ВСЕГДА если внутри функции есть this - ожидается, что она 
будет вызываться в контексте какого-нибудь объекта.

- У СТРЕЛОЧНЫХ ФУНКЦИЙ НЕТ "THIS"

Стрелочные функции особенные. Своего собственного this у них нет.
Если используем this внутри стрелочной функции - его значение берётся из внешней функции.

Так, в примере ниже, arrow() использует значение this из внешнего метода user.sayHi():

let user = {
    firstName: "Илья",
    sayHi() {
      let arrow = () => alert(this.firstName);
      arrow();
    }
};
user.sayHi(); // Илья

Это - особенность стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь
отдельное значение this, а хотим брать его из внешнего контекста.