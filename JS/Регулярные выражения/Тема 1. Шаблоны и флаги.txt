- ВВЕДЕНИЕ
Регулярное выражение состоит из "шаблона" и необязательных "флагов".

Два СИНТАКСИСА для создания регулярного выражения:
1. "Длинный": regexp = new RegExp('Шаблон','Флаги');
2. "Короткий": regexp = /шаблон/флаги.

Слеши /.../ говорят JS о том, что он наткнулся на регулярное выражение.
regexp - объект встроенного класса RegExp.

Разница между двумя синтаксисами - возможность вставки переменных.
"Короткий" синтаксис (/.../) не позволяет делать подстановку переменных.

Т.О.:
"Короткий" синтаксис - слеши - используем тогда, когда на момент написания кода точно знаем,
как будет выглядеть регулярное выражение.

"Длинный" синтаксис - new RegExp - используем для создания регулярных выражений "на лету".
из некой динамически сгенерированной строки.

Пример:
let tag = prompt("Какой тег вы хотите найти?", "h2");
let regexp = new RegExp(`<${tag}>`); 
//# То же, что /<h2>/  при ответе "h2" на prompt выше

- ФЛАГИ
Флаги влияют на поиск в регулярном выражении.
Всего в JS 6 флагов:

1. i
Показывает, что поиск не должен зависеть от регистра (A = a)

2. g
Показывает, что нам требуется найти ВСЕ совпадения. Без этого флага ищет только первое.

3. m
Многострочный режим - будет рассмотрен в теме 3 данного каталога.

4. s
Режим "dotall" - точка соответствует символу перевода строки "\n" 

5. u
Включает поддержку Юникода. Помогает корректно обработать суррогатные пары.

6. y
Поиск на конкретной позиции в тексте.

- STR.MATCH() - Поиск
Поиск регулярок интегрирован в методы строк.

Так, метод str.match(regexp) возвращает совпадение с рег.выр. для строки str.
У данного метода есть 3 "режима" работы:

1. Используем флаг "g" - получаем массив всех совпадений
# Простейший пример: 
{
    let str = "Любо, братцы, любо!";
    alert( str.match(/любо/gi) ); //# Любо,любо (массив из 2х подстрок-совпадений)
}

2. Флага "g" нет? Получаем первое совпадение, но тоже в виде массива.
В данном массиве будет только элемент с индексом 0. 
Зачем массив? Он имеет доп. свойства, которые могут оказаться полезны нам.
# Пример:
{
    let str = "Любо, братцы, любо!";
    let result = str.match(/любо/i); //# Не используем флаг g
    
    alert( result[0] );     //# получаем массив с "Любо" (первое совпадение)
    alert( result.length ); //# Длина массива = 1 элемент
    
    //# А вот полезная дополнительная информация:
    alert( result.index );  //# 0 (позиция совпадения)
    alert( result.input );  //# Любо, братцы, любо! (исходная строка)
}

3. Совпадений нет? Получаем "null".
Важный нюанс в том, что мы не просто получаем пустой массив, а получаем именно "null".

# Пример: 
{
    let matches = "JavaScript".match(/HTML/); //# Получим null
        if (!matches.length) { alert("Ошибка в строке выше") }
    //# Ошибка: Alert мы не получим - у null нет свойства length.
}

Кстати, одной хитростью можно заставить получать пустой массив, вместо null:
{
    let matches = "JavaScript".match(/HTML/) || [];
    if (!matches.length) { alert("Совпадений нет"); //# Вот теперь работает!
    } 
}

- STR.REPLACE() - Замена
Метод str.replace(regexp, replacement) позволяет найти и заменить
совпадение с "regexp" в строке "str" на "replacement".

Если флаг "g" отсутствует - будет найдено и заменено только первое совпадение.

# Пример:
{
//# без флага g
    alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

//# с флагом g
    alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
}

В качестве "replacement" мы можем использовать специальные комбинации символов:

1. $&
Вставляет всё найденное совпадение.

2. $`
Вставляет часть строки до совпадения.

3. $'
Вставляет часть строки после совпадения.

4. $n
Если n - 1 или 2 значное число - вставляет содержимое n-ой скобочной группы
регулярного выражения. Больше об этом в теме "Скобочные группы" данного каталога.

5. $<name>
Вставляет содержимое скобочной группы с именем "name".

6. $$
Вставляет символ "$".

# Пример:
{
    alert( "Люблю HTML".replace(/HTML/, "$& и JavaScript") );
    //# Люблю HTML и JavaScript
}

- REGEXP.TEST() - Проверка
Метод regexp.test(str) проверяет, есть ли хоть одно совпадение.
Если да - возвращает "True". Если нет - соответственно, "False".

# Пример:
{
    let str = "Я ЛюБлЮ JavaScript";
    let regexp = /люблю/i;
    alert( regexp.test(str) ); //# Вернёт true
}

- ИТОГО:

1. Шаблоны и флаги:
Регулярное выражение состоит из шаблона и необязательных флагов: g, i, m, u, s, y.

2. Аналог поиска подстроки:
Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному
выражению в принципе аналогичен поиску подстроки.

3. str.match(regexp)
Метод str.match(regexp) ищет совпадения: все, если есть флаг g, иначе только первое.

4. str.replace(regexp, replacement)
Метод str.replace(regexp, replacement) заменяет совпадения с regexp на replacement:
все, если у регулярного выражения есть флаг g, а иначе только первое.

5. regexp.test(str)
Метод regexp.test(str) возвращает true, если есть хоть одно совпадение,
иначе возвращает false.
