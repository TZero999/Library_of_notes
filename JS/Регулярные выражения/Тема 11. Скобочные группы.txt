* СКОБОЧНЫЕ ГРУППЫ
Часть шаблона допустимо заключать в круглые скобки ().
Это называется "Скобочная группа".

У этого выделения есть 2 эффекта:
1) Позволяет поместить часть совпадения в отдельный массив;
2) Если установить квантификатор после скобок - он будет применяться ко всем содержимому скобки.

* ПРИМЕР 'gogogo':
Если мы напишем шаблон /go+/ регулярка будет искать символ "g", после которого идёт хотя бы один символ "o".
Символ "o" может повторяться сколь угодно раз. Шаблон будет находить "go", "goooo", "goooooooo" и т.д.

Вместо того, чтобы писать сложный шаблон мы можем использовать скобочную группу.
# Вот так: 
{   
    let str = 'Gogogo now!' 
    alert( str.match(/(go)+/ig) ); //# ["Gogogo"]
}

* ПРИМЕРЫ с доменами:
{   
    hostname('gmail.com');                                  //# [ 'gmail.com' ]
    hostname('users.gmail.com');                            //# [ 'users.gmail.com' ]
    hostname('learn.javascript.ru/regexp-groups');          //# [ 'learn.javascript.ru' ]
    
    function hostname(str){
        console.log(result = str.match(/(\w+\.)+\w+/g));
    }
}

Возможно шаблон стоило бы изменить на /[-.\w]+@([\w-]+\.)+[\w-]+/g, чтобы учитывать домены, в которых есть дефис "-".

* СОДЕРЖИМОЕ СКОБОК В match():
Поисковый движок запоминает содержимое каждой скобочной группы.
Это позволяет получить результат по каждой отдельной скобочной группе.

Метод str.match(regexp) (если у регулярки regexp нет флага g!!!), ищет первое совпадение и возвращает его в виде массива:

Позиция 0 - всё совпадение целиком.
Позиция 1 – содержимое первой скобочной группы.
Позиция 2 – содержимое второй скобочной группы.
И т.д…

Причём, к слову, на выходе мы получим не массив, а строку!

# Пример:
{
    let str = '<h1>Hello, world!</h1>';
    let tag = str.match(/<(.*?)>/);
    alert( tag[0] ); //# <h1>
    alert( tag[1] ); //# h1
}

Невероятно удобная штука. Однако я не зря выделил фразу "если у регулярки regexp нет флага g!!!".
Порой скобочная группа может работать не так, как хотелось бы. Виной этому вполне может оказаться флаг "g".
Потому несмотря на все удобства стоит быть внимательным, особенно если ваш tag[1] и т.п. возвращает
"undefined", вместо результата.

* ВЛОЖЕННЫЕ ГРУППЫ:
Скобки могут быть вложенными.

Так, например, в <span class="my"> нас может интересовать:
1) Всё содержимое тега;
2) Название тега;
3) Атрибуты тега.

# Пример подходящего для всех 3-ёх случаев шаблона:
{
    let str = '<span class="my">';
    let regexp = /<(([a-z]+)\s*([^>]*))>/;
    let result = str.match(regexp);

    alert(result[0]); //# <span class="my">
    alert(result[1]); //# span class="my"
    alert(result[2]); //# span
    alert(result[3]); //# class="my"
}

* НЕОБЯЗАТЕЛЬНЫЕ ГРУППЫ
Даже если скобочная группа "необязательная" (то бишь имеет после себя квантификатор "?"),
соответствующий элемент массива всё равно существует и имеет тип undefined.

# Пример:
{
    let match = 'a'.match(/a(z)?(c)?/);
    alert( match.length ); //# 3
    alert( match[0] ); //# a (совпадение)

    alert( match[1] ); //# тут undefined
    alert( match[2] ); //# и тут undefined
}

Как видно, массив имеет длину 3, причём скобочные группы пусты и имеют значение undefined.

А теперь ещё более "приятный" пример:
{
    let match = 'ac'.match(/a(z)?(c)?/)
    
    alert( match.length ); //# 3
    alert( match[0] ); //# ac (совпадение)
    alert( match[1] ); //# тут undefined
    alert( match[2] ); //# а тут совпадение "c"
}

Длина массива равна 3, но для группы (z)? ничего нет, поэтому результат: ["ac", undefined, "c"].
Неприятная особенность.

* ПОИСК ВСЕХ СОВПАДЕНИЙ С ГРУППАМИ: matchAll()
! matchAll довольно новая функция, может понадобиться полифил.

При поиске всех совпадений (флаг "g") метод match не вернёт нам значения для  скобочных групп.
{
    let str = '<h1> <h2>';
    let tags = str.match(/<(.*?)>/g);
    
    alert( tags );     // [ '<h1>','<h2>' ]
    alert ( tags[0] ); //# h1
    alert ( tags[1] ); //# h2
}

Результат – массив совпадений, но без деталей о каждом. 
Но на практике скобочные группы тоже часто нужны.

Здесь мы можем использовать метод str.matchAll(regexp).
Он, как и str.match(regexp), ищет совпадения, но у него есть три отличия:
1) Возвращает  НЕ МАССИВ, а ПЕРЕБИРАЕМЫЙ ОБЪЕКТ;
2) При наличии флага "g" возвращает каждое совпадение в виде массива со скобочными группами;
3) Если совпадений нет - возвращает пустой перебираемый объект, а не "null".

# Пример использования "matchAll":
{
    let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

    alert(results); // [object RegExp String Iterator] //# Не массив, а перебираемый объект

    alert(results[0]); //# undefined (*)

    results = Array.from(results); //# превращаем в массив
    alert(results[0]); //# <h1>,h1 (первый тег)
    alert(results[1]); //# <h2>,h2 (второй тег)
}