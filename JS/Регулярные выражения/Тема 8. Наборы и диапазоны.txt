Несколько символов или символьных классов в квадратных скобках [...] означает 
"искать любой символ из заданных"

* НАБОРЫ:
Для примера [eaо] означает "найди один из трёх символов: а, е или о".

Это называется "набор".
Наборы могут использоваться в регулярках вместе с обычными символами.

# Вот пример: ищем [т или х], после которых идёт "оп"
{ 
    alert( "Топ, хоп, хлоп!".match(/[тх]оп/gi) ); //# ["Топ", "хоп"]
}

Стоит обратить внимание, что в наборе несколько символов, 
но в результате набо соответствует ровно одному символу.

# Переработаем предыдущий пример:
{
    alert( "Топ, хоп, хлоп!".match(/.[тхл]оп/gis) ); //# ["хоп","хлоп"]
}
В этом примере мы не найдём "Топ" потому что "любой символ" означает БУКВАЛЬНО любой символ,
но не его отсутствие. И флаг \s тут не поможет.

Пока у меня не выходит написать регулярку для нахождения всех 3-ёх совпадений, 
не изменяя саму входящую строку...

# Пример, который не даст совпадений:
{
    alert( "Вуаля".match(/В[уа]ля/) ); //# null, нет совпадений
}
В примере мы ищем "В", а затем [у или а], а потом "ля". Выходит, мы нашли бы "Вуля" или "Валя",
но не строку из 5 символов "Вуаля".

* ДИАПАЗОНЫ:
Квадратные скобки могут содержать не только наборы, но и диапазоны символов.

К примеру, [a-z] соответствует символу в диапазоне от "a" до "z".
А [0-5] означает цифры в дипазоне от 0 до 5.
//# Кстати, а вот и заготовочка под "часы"...

# Пример, найдём шестнадцатиричное число в формате "xDD":
{
    alert( "Exception 0x0F".match(/x[0-9A-F][0-9A-F]/g) ); //# x0F
}

В примере выше мы ищем сразу 2 диапазона:
Ищется символ, который либо цифра от 1 до 9, либо буква от A до F.

Хотим найти буквы и в верхнем и в нижнем регистре?
Можем добавить ещё диапазон "a-f": [0-9A-Fa-f]. Ну или поставить у регулярного выражения флаг i.

* ДИАПАЗОНЫ С СИМВОЛЬНЫМИ КЛАССАМИ:
Мы можем использовать символьные классы внутри [...]:
{
    regexp = /\w[\w-]\d\d/; 
    alert( "X-56".match(regexp) ); //# X-56;
    alert( "Xs98".match(regexp) ); //# Xs98; 
}

Здесь наш шаблон звучит так: найди последоватеьность "Символ-символ/тире-цифра-цифра".
Следовательно мы можем использовать несколько символьных классов вместе.

Стоит понимать, что символьные классы - просто сокращения для наборов символов
\d – то же самое, что и [0-9],
\w – то же самое, что и [a-zA-Z0-9_],
\s – то же самое, что и [\t\n\v\f\r ], плюс несколько редких пробельных символов Юникода.

* МНОГОЯЗЫЧНЫЙ АНАЛОГ \w:
Так как символьный класс \w является сокращением для [a-zA-Z0-9_].
Получается, что кириллические буквы или, например, иероглифы, найти не удастся.

Поэтому нам пригодится более универсальный шаблон, который сможет помочь найти символы в 
словах на любом языке.

Это легко делается с Юникод-свойствами: [\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]

Здесь мы используем следующие Юникодные свойства:
- Alphabetic (Alpha) – для букв,
- Mark (M) – для акцентов,
- Decimal_Number (Nd) – для цифр,
- Connector_Punctuation (Pc) – для символа подчёркивания '_' и подобных ему,
- Join_Control (Join_C) – два специальных кода 200c и 200d, используемые в лигатурах, например, арабских.

# Пример использования нашего универсального шаблона:
{
    let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;
    let str = `Hi 你好 12`; //# будут найдены все буквы и цифры
    alert( str.match(regexp) ); //# [H,i,你,好,1,2]
    
    //# А теперь найдём сразу 2 символа:
    regexp2 = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]./gu;
    alert( str.match(regexp2) ); //# [Hi,你好,12]
}

* ИСКЛЮЧАЮЩИЕ ДИАПАЗОНЫ:
Помимо обычных диапазонов есть ещё и исключающие диапазоны.
Синтаксис: [^...].

Они обозначаются символом каретки ^ в начале диапазона и соответствуют любому символу, КРОМЕ
заданных в диапазоне.

Например:
1) [^aeyo] – любой символ, за исключением 'a', 'e', 'y' или 'o'.
2) [^0-9] – любой символ, за исключением цифры. То же, что и \D.
3) [^\s] – любой непробельный символ. То же, что и \S.

# Пример поиска любых символов, кроме латинских букв, цифр и пробелов:
{
    alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); //# [@,.]
}

* ЭКРАНИРОВАНИЕ ВНУТРИ ДИАПАЗОНОВ И НАБОРОВ:
Если нам нужно включить в поиск специальный символ мы экранируем его обратным слэшем.
А если нужен обратный слэш - удваиваем его.

В квадратных скобках большинство спецсимволов можно использовать без экранирования:
- Символы . + () никогда не экранируют;
- Тире не экранируют в начале или в конце (ведь иначе оно задаёт диапазон);
- Каретку ^ экранируют только в начале (ведь он означает исключение);
- Закрывающую квадратную скобку (ведь он означает конец диапазона).

Другими словами без экранирования можно использовать любые спецсимволы, 
кроме случаев, когда они что-то означают внутри набора, или диапазона.

Точка "." внутри квадратных скобок - просто точка. Шаблон [.,] ищет НЕ любой символ или запятую,
А будет искать либо точку, либо запятую.

В приведённом ниже примере регулярное выражение [-().^+] ищем один из символов -().^+
{
    let regexp = /[-().^+]/g;
    alert( "1 + 2 - 3".match(regexp) ); //# Совпадения [+,-]

    //# Но можно и экранировать все возможные символы:
    let regexp = /[\-\(\)\.\^\+]/g;
    alert( "1 + 2 - 3".match(regexp) ); //# Тоже работает
}

