Синтаксис OBJ = {} позволяет создать 1 объект.

А если нам надо создать много однотипных объектов?
Здесь поможет функция-конструктор и оператор "new".

- ФУНКЦИЯ-КОНСТРУКТОР:

В принципе функции-конструкторы являются обычными функциями.
НО есть два отличия:
1) Имя функции-конструктора ВСЕГДА обязано начинаться С БОЛЬШОЙ БУКВЫ;
2) Функция-конструктор должна выполняться ТОЛЬКО с помощью оператора "new".

Пример:

function User(name) {
    this.name = name;
    this.isAdmin = false;
  }
let user = new User("Jack");

Если вызовем алерты с user.name и user.isAdmin получим "Jack" и "false".

Когда вызываем функцию new User(...) происходит следующее:
1) Сначала создаётся пустой объект и он присвается как значение this.
Получаем, что this = новый пустой объект.
2) Выполняется тело функции User. Причём оно модифицируется под this.
В this добавляются новые свойства из User.
3) Когда тело функции полностью выполнено - возвращается значение this.

Выглядит это так:

let user = new User("Jack");
  /* function User(name) {
     this = {};  (неявно)
     this.name = name;
     this.isAdmin = false;
     return this;  (неявно)
}*/

Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), new User("Alice") и т.д.
Данная конструкция гораздо удобнее и читабельнее, чем многократное создание литерала объекта.

- ЕЩЁ РАЗ:
Технически ЛЮБАЯ функция (кроме стрелочных, у них нет this) может использоваться как конструктор.
Его можно запустить с помощью команды "new" и он выполнит указанный выше алгоритм.
Подобные функции ОБЯЗАНЫ начинаться с заглавной буквы. Это - общепринятое соглашение.
Это даёт понять,  что функция будет вызываться с помощью "new".

- new function() - :
Если в коде большое число строк для создания одного сложного объекта, то можно обернуть эти строки в 
функцию-конструктор (она будет создана и сразу же вызвана). Вот так:

// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};

Такой конструктор не может быть вызван снова, т.к. он нигде не сохраняется.
Т.О. этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект,
но без возможности его повторного использования в будущем.

- Проверка на вызов в режиме конструктора: new.target:
СИНТАКСИС ЭТОГО РАЗДЕЛА ИСПОЛЬЗУЕТСЯ РЕДКО!

Это специальное свойство "new.target", когда используется внутри функции, позволяет проверить,
вызвана ли эта функция оператором new или нет.

Если функция вызвана обычным способом свойство new.target будет undefined.
Если же функция вызвана с помощью new - new.target будет равен самой функции.

Пример:

function User() {
    alert(new.target);
}
//Если без "new":
User(); // undefined

//Если с "new":
new User(); // function User { ... }

- Возврат значения из конструктора, return
Обычно конструктор не имеет оператора return, т.к. их задача - записать всё необходимое в this. 
This становится результатом.

НО если return всё же есть, то применяется простое правило:
1) При вызове return с объектом, вместо this возвращается объект.
2) При вызове return с примитивным значением, оно игнорируется.

Другими словами: 
1) Return с объектом - вернёт этот объект;
2) Во всех остальных случаях вернётся this.

В основном это не используется. Return опускается, так как и так будет возвращён this.

Но вот пример возвращения объекта:
function BigUser() {
    this.name = "John";
    return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект

- Проспуск скобок:

Кстати, "let user = new User" и "let user = new User()" даст одинаковый результат.
Пропуск скобок - плохая практика, но она разрешена спецификацией.

- Создание методов в конструкторе:

Конструкторы дают нам гибкость для создания объектов.
Функции-конструкторы могут иметь параметры, определяющие как создавать объект и что в него записывать.

Конечно же к this можно добавлять не только свойства, но и методы.

Пример:

function User(name) {
    this.name = name;
    this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
    };
  }
  
let john = new User("John");
john.sayHi(); // Меня зовут: John

Для создания более сложных объектов используются "Классы": https://learn.javascript.ru/classes

- ИТОГО:

1) Функции-конструкторы - обычные функции с некоторыми общепринятыми догмами именования;
2) Конструкторы следует вызывать только с помощью "new". Такой вызов подразумевает создание пустого this,
с последующим заполнением его и возвратом.

Обычно конструкторы используются для создания сножества похожих объектов.
