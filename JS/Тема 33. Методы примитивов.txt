JS позволяет нам работать с примитивными типами данных, как если бы они являлись объектами.
И у них есть свои методы.
В этой теме разберём, как это всё работает, ведь примитивы - не объекты.

- Ключевые отличия примитивов и объектов:

ПРИМИТИВЫ:
1) Это значения примитивного типа;
2) Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

ОБЪЕКТЫ:
1) Могут хранить множество значений как свойства;
2) Объявляются при помощи {}. Например: {name : "Рома", age : 30};
3) В JS есть и другие виды объектов (например, функции).

Одно из лучших особенностей объектов - хранение функции в качестве свойства объекта:
let roma = {
    name: "Рома",
    sayHi: function() {
      alert("Привет, дружище!");
    }
};
roma.sayHi(); // Привет, дружище!

Есть множество встроенных объектов: работающих с датами, ошибками, html-элементами и т.д.
НО есть у объектов и другая сторона - они нуждаются в доп ресурсах для поддержания внутренней структуры.

- Примитив как объект

Создатель JS столкнулся с парадоксом:
1) Хортелось бы, чтобы мы могли обращаться к примитивам посредством методов - это расширило бы их возможности.
2) Хотелось бы, чторбы примитивы при этом оставались "лёгкими" и "быстрыми".

В итоге было решено следующее (решение довольно неуклюжее):
1) Примитивы остаются примитивами. 1 примитив - 1 значение;
2) Язык позволяет осуществить доступ некоторых примитивов к методам (строк, чисел, символов, булевых значений);
3) Чтобы это осуществить создаётся специальный "объект-обёртка", который даёт эту функциональность, а затем удаляется.

Каждый примитив имеет свой собственный "объект-обёртку": String, Number, Boolean, Symbol и BigInt.
Т.О. они имеют разный набор методов.

К примеру, есть метод "str.toUperCase()" (где str - переменная с типом string), который возвращает строку в верхнем регистре:
let string = "Привет";
alert( string.toUpperCase() ); // ПРИВЕТ

Выглядит просто, но "под капотом" совершается 3 действия:
1) Строка string - примитив. Когда обращаются к её "свойству" методом выше - создаётся специальный объект,
который знает значение строки string и имеет нужный нам метод toUpperCase();
2) Этот метод запускается и возвращает нам новую строку, которая показывается нам в alert-е;
3) Специальный объект удаляется, оставив только примитив str.

Цель достигнута, примитивы обладают методами, но остаются "лёгкими".
Причём движок JS сильно оптимизировал этот процесс.
Даже научился опускать создание специального объекта, но придерживается спецификации и работает всегда так, будто создаёт его.

Числа тоже имеет собственный набор методов. Вот пример:
let num = 1.23456789;
alert( num.toFixed(2) ); // Вовзращает нам округлённое до двух знаков число 1.23

- ПРЕДУПРЕЖДЕНИЕ!
Некоторые языки (Java и т.д.) позволяют создание "объектов-обёрток" для примитивов при помощи такого синтаксиса:
new Number(1) или new Boolean(false)

В JS это тоже возможно по исторически сложившимся причинам, но НЕ РЕКОМЕНДУЕТСЯ!
Последствия порой могут быть КРАЙНЕ НЕГАТИВНЫМИ.
Вот примеры:

alert( typeof 0 ); // "число"
alert( typeof new Number(0) ); // "object"!

Объекты в if всегда дают true. Получаем вот такой плохой пример:

let zero = new Number(0);
if (zero) {  // zero сейчас является объектом
  alert( "zero имеет «истинное» значение?!?"); Да, алерт будет показан, так как if вернёт "true"!
}

Однако БЕЗ ОПЕРАТОРА NEW использование функций String/ Number/ Boolean - вполне разумно и даже полезно.
Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
Вот пример:

let num = Number("123"); // превращает строку в число
Таким Образом можно преобразовывать типы данных.

- null и undefined не имеют методов
Особенные примитивы "null" и "undefined" - исключения. У них нет соответствующих
"объектов-обёрток", и они не имеют никаких методов. В некотором смысле они "самые примитивные".
Все попытки вызвать у них какое-либо свойство приведёт к ошибке: alert(null.test); // TypeError: Cannot read properties of null (reading 'test')

- ИТОГО

1) Все примитивы (кроме null и undefined) предоставляют множество полезных методов.
С их разнообразием познакомимся в будущем.

2) Формально эти методы работают при помощи временных объектов, но движки JS хорошо оптимизировали этот процесс.