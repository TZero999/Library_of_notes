- Блоки кода и циклы, IIFE
Лексическое окружение существует для любых блоков кода, заключённых в {...}

Так, лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.
Пример:
    let phrase = 'Hello';
    if (true) {
        let user = 'John';
        alert (`${phrase}, ${user}!`);
    }
alert( user);

На alert-е, вызывающем переменную user получим ошибку.
Т.О. становится ясно, что переменная user существует только для блока кода if(...){...}.

Это происходит из-за того, что блок кода if создал своё лексическое окружение.
У него есть ссылка на внешнее окружение (поэтому phrase доступна).
Но лексические окружения работают "изнутри-наружу". alert не сможем получить доступ к переменой user, так как она не находится
во внешнем для него окружении. "Проникнуть" внутрь блока кода "if" он не сможет.

- For, while
Для цикла у КАЖДОЙ итерации своё ОТДЕЛЬНОЕ лексическое окружение!
Пример:
    for (let i = 0; i < 10; i++) {...} //# у каждой итерации своё окружение с {i: value}.
alert (i); //# Ошибка, i не объявлена.

let i визуально находится вне блока {...}. Но For особенная в этом смысле конструкция - у каждой итерации цикла
своё лексическое окружение со своим текущим i внутри. Вне цикла эта переменная вызвана быть не может.

- Блоки кода
Мы можем использовать блоки кода, чтобы изолировать переменные в "локальной области видимости".

Например, в браузере все скрипты (кроме type = 'module') разделяют общее глобальное окружение.
Если мы создадим глобальную переменную в одном скрипте - она станет досьупна и в других.
Это может стать источником конфликтов, ведь если 2 скрипта используют одинаковое имя переменной - они будут перезаписывать её.

Во избежание этого мы можем использовать блок кода для изоляции всего скрипта или его части.
Пример:
    {
    let message = 'Hello';
    alert( message); //# Hello
    }
alert( message); //# ошибка, message не определена. 

Таким образом блоки кода помогают изолировать переменные благодаря собственному лексическому окружению блоков кода.

- IIFE
В прошлом в JS не было лексического окружения на уровне блоков кода.

Программистам пришлось придумать трюк - Immediately-invoked Function Expressions (IIFE).
Это значит "Функция, запускаемая сразу же после объявления".

На текущий момент времени нам не стоит пользоваться этим трюком, но ознакомиться с IIFE всё же стоит.

IIFE вышлядит следующим образом:
    (function() {
        let message = 'Hello';
        alert( message); //# Hello
})();

Здесь создаётся и сразу же вызывается Function Expression. Так код выполняется сразу и у него есть свои локальные переменные.

Function Expression обёргуто в скобки (function{...}). Движок JS думает, что в этом месте встречает Function Declaration, но у функции нет имени.
Function Declaration без имени, не обёрнутый скобками = ошибка "Error: Unexpected token".

Добавление имени не поможет, т.к. JS не позволит нам вызвать функцию немедленно.

Поэтому скобки вокруг функции - это трюк, позволяющий показать JS , что функция была создана в контексте какого-то другого выражения.
Тогда JS думает, что функция - это функциональное выражение, созданное в контексте другого выражения и ей не нужно имя, а выполнить её можно сразу.

- Пути создания IIFE
Но можно использовать не только скобки, да и скобки можно использовать по разному:
1) (function() { alert( скобки вокруг функции)})();
2) (function() { alert( скобки вокруг всего выражения)}());
3) !function() { alert( выраженеи начинается с логического НЕТ)}();
4) +function() { alert( выражение начинается с унарного плюса)}();

Такие трюки можно найти в старом коде. Встретив такое в коде надо понимать, что мы имееем дело с IIFE и функциями, которые выполняются немедленно.

- Сборка мусора
Обычно лексическое окружение очищается сразу же после выполнения функции.
Например:
    function f() {
        let value_1 = 123;
        let value_2 = 456;
    }
f();

Здесь всё просто - есть 2 значения, они являются свойствами лексического окружения функции.
После того, как f() завершится - её лексическое окружение станет недоступно и удалится.

Но если в функции есть вложенная функция, которая всё ещё доступна по выполнению f() - её свойство [[ENVIRONMENT]] будет
"удерживать" внешнее лексическое окружение и оставлять его "живым".
Пример:
    function f() {
        let value = 123;
            function g() { alert(value); }
        return g;
    }
let g = f();

Если функция f() вызывается несколько раз - КАЖДЫЙ РАЗ ДЛЯ НЕЁ СОЗДАЁТСЯ СВОЁ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ.
И все объекты этих лексических окружений ОСТАЮТСЯ В ПАМЯТИ.

В коде выше лексическое окружение функций станет недоступным, когда станет недоступным переемнная g.
Для этого надо "обнулить" g:
"g = null;".

- Оптимизация на практике - проблема с V8
В теории, пока жива функция - все внешние переменные тоже живы.

На практике движки JS пытаются оптимизировать этот вопрос. Они анализируют использование переменных и, если по коду легко понять,
что внешняя переменная больше не используется - удаляют её.

ВАЖНЫЙ побочный эффект такой оптимизации в V8 (chrome и Opera) в том, что такая переменная становится недоступной при отладке кода.

Например, у нас есть код:
    function f() {
    let value = Math.random();
        function g() {
        debugger; //# В консоли: напишите alert(value); Такой переменной нет!
        }
     return g;
    }
let g = f();
g();

Команда debugger вызовет точку остановки в ChromeDevTools.
Попытавшись на этой точке остановки отследить нашу переменную value мы узнаем, что она не существует.
В теории она должна быть доступна, но попала под оптимизацию движка.

Эту особенность V8 полезно знать. Если вы занимаетесь отладкой в Chrome/Opera, рано или поздно вы с ней встретитесь.
Это не баг в отладчике, а скорее особенность V8.