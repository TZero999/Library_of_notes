Шпаргалка по методам массива:

- Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.

splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

- Для поиска среди элементов:

1) indexOf (item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
2) lastIndexOf (item, pos) - То же, что и indexOf, но начинает поиск с конца массива.
3) includes (item, from) – возвращает true, если в массиве имеется элемент value, в противном случае false.
4) arr.find (function(item, index, array)) - ищет первый попавшийся элемент и возвращет true.
5) arr.filter (function(item, index, array)) – фильтрует элементы через функцию и возвращает все значения, удовлетворяющие функции.
findIndex похож на find, но возвращает индекс вместо значения.

- Для перебора элементов:

1) forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

- Для преобразования массива:

1) map (func) – создаёт новый массив из результатов вызова func для каждого элемента.
2) sort (func) – сортирует массив «на месте», а потом возвращает его.
  Самый аккуратный способ записи: arr.sort( (a, b) => a - b ) - сортировка по возрастанию
  alert( countries.sort( (a, b) => a.localeCompare(b) ) ) - сортировка строк.
3) reverse() – «на месте» меняет порядок элементов на противоположный и возвращает изменённый массив.
4) split (' ') - разбивает строку на массив, вычисляет элементы по разделителю в скобках. 
5) join (';') –  создаёт строку из элементов массива, разделяет их указанным в скобках знаком.
6) reduce (function(accumulator, item, index, array) {...} [initial]) - помогает найти "единое значение" на основе всего массива.
Функция применяется по очереди и "переносит" результат на следующий вызов. "initial" - начальное значение.
Если нет "initial" - берёт первый элемент массива, перебор начинает со второго.
7) reduceRight (function(accumulator, item, index, array)) – то же, что и reduce, но проходит по массиву справа налево.


- Дополнительно:

1) Array.isArray(arr) - проверяет, является ли arr массивом.
Изученных нами методов достаточно в 99% случаев, но существуют и другие.

2) arr.some(fn) - проверяет массив, вызывая функцию для каждого элемента.
Если есть хоть один true возвращает true. Аналогия map.
Метод ведёт себя примерно так же, как оператор "ИЛИ" (||) :
если fn возвращает истинное значение, arr.some() немедленно возвращает true и останавливает перебор остальных элементов.


3) arr.every(fn) - похож на arr.some, но ведёт себя не как логическое ИЛИ, а как логическое "И" (&&):
если fn возвращает ложное значение, arr.every() немедленно возвращает false и прекращает перебор остальных элементов.

4) function arraysEqual(arr1, arr2) { return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]) }
alert( arraysEqual([1, 2], [1, 2])); // true

5) arr.fill(value, start, end) – заполняет массив ПОВТОРЯЮЩИМИСЯ value, начиная с индекса start до end.

6) arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

7) arr.flat(depth)/arr.flatMap(fn) создаёт новый плоский массив из многомерного массива.

Полный список есть в справочнике MDN: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array