Во многих языках есть символы, состоящие из некоторого основного символа со знаком сверху или снизу.

Например, буква a — это основа для àáâäãåā.
Наиболее используемые составные символы имеют свой собственный код в таблице UTF-16.
Но не все, в силу большого количества комбинаций.

Чтобы поддерживать любые комбинации, UTF-16 позволяет использовать несколько Юникодных символов:
основной и дальше один или несколько особых символов-знаков.

Если после S добавить специальный символ "точка сверху" (код \u0307), он отобразится как Ṡ:

alert( 'S\u0307' ); // Ṡ

Можно добавлять несколько символов подряд. 
Добавляем символ "точка снизу":
alert( 'S\u0307\u0323' ); // Ṩ

Это даёт большую гибкость. Но есть проблема: 
Порядок символов может быть разным. А это проблема сравнения символов.
Вот пример:

let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху
alert( `s1: ${s1}, s2: ${s2}` );
alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)

Для решения этой проблемы есть алгоритм «ЮНИКОДНОЙ НОРМАЛИЗАЦИИ», приводящий каждую строку к единому «нормальному» виду.
Его реализует метод str.normalize().
Вот как он работает:

alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

Кстати, в нашем случае normalize() «схлопывает» нашу последовательность в символ \u1e68 — S с двумя точками.

Разумеется, так происходит не всегда. Просто Ṩ — это достаточно часто используемый символ.
Создатели UTF-16 включили его в основную таблицу и присвоили ему собственный код.