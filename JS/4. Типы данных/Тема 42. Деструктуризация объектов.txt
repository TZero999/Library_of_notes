Деструктурирующее присваивание работает и с объектами.

Синтаксис:
let {var1, var2} = {var1:…, var2:…}

Предположим есть объект, который мы хотим разделить на переменные.
Левая сторона содержит шаблон для соответствующих свойств, правая - существующий объект.

Пример:
    let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  
  let {title, width, height} = options;
  alert(title);  // Menu
  alert(width);  // 100
  alert(height); // 200
//# Т.О. свойства options.title, .width, .height присваиваются соответсвующим переменным.

Кстати, порядок можно менять. Вот так тоже сработает:
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
И так тоже: let {height, width, title} = options;

Потому "порядок не имеет значения!"

- Если мы хотим присвоить свойствам другие, отличающиеся названиями переменные:

Если у нас есть необходимость или желание присвоить другие названия переменным,
например options.width присвоить переменной w, надо использовать двоеточие.

Синтаксиси: { sourceProperty: targetVariable }

Пример:
    let options = {
    title: "Menu",
    width: 100,
    height: 200
    };
  
  let {width: w, height: h, title} = options; //# Новые переменные: w, h и title. 
  alert(title);  // Menu
  alert(w);      // 100
alert(h);      // 200

"Значения по умолчанию"
Значения по умолчанию используются, как и в ситуации с массивами:
    let options = {
    title: "Menu"
    };
  
    let {width = prompt("width?"), title = prompt("title?")} = options;
  
    alert(title);  //# Сначала у нас запросят значение width. Затем вернёт нам Menu
alert(width);  //# Затем нам вернётся значение, введ

"Двоеточие и равно можно совмещать"
Пример:
    let options = {
    title: "Menu"
  };
  
    let {width: w = 100, height: h = 200, title} = options;
    alert(title);  // Menu
    alert(w);      // 100
alert(h);      // 200

"Берём только то, что необходимо"
Пример:
    let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  
  let { title } = options;//# Берём только title.
alert(title); // Menu

"Остаток объекта"
Если в объекте есть ненужные объекты - можно использовать троеточие, как в массивах.
Но в некоторых старых браузерах это не поддерживается, поэтому желательно использовать babel для полифила.

Пример:
    let options = {
    title: "Menu",
    height: 200,
    width: 100
    };
  
    let {title, ...rest} = options; //# title="Menu", rest={height: 200, width: 100}
  
    alert(rest.height);  // 200
alert(rest.width);   // 100

"Предупреждение о let"
let {…} = {…} - обычный синтаксси.
Если переменная для деструктуризации уже существует - нельзя просто убрать let!

Если просто уберём let - JS посчитает, что видит блок кода, выдаст нам ошибку.

Поэтому если хотим избежать let надо использовать скобки.
Вот синтаксис:
({ a, b, c } = {a: "Menu", b: 200, c: 100});

- Вложенная деструктуризация

Если объект или массив содержит другие вложенные объекты/ массивы - мы можем использовать более сложные шаблоны.

Вот пример: "Options" хранит в себе другой объект в свойстве "size" и массив в свойстве "item".
Извлекаем из них данные:

    let options = {
    size: {
      width: 100,
      height: 200
    },
    items: ["Cake", "Donut"],
    extra: true
  };
  
  //# деструктуризация разбита на несколько строк для ясности
  let {
    size: { //# size сюда
      width,
      height
    },
    items: [item1, item2], //# элементы к items
    title = "Menu" //# отсутствует в объекте, используется значение по умолчанию.
  } = options;
  
  alert(title);  //# Menu
  alert(width);  //# 100
  alert(height); //# 200
  alert(item1);  //# Cake
alert(item2);  //# Donut

- Умные параметры функций. Суть проблемы:

Бывает функция имеет много параметров, которые не всегда обязательны.

Пример: функция, создающая меню:
    function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
    // ...
}
Это - ПЛОХОЙ способ создать такую функцию.

Проблема будет в том, что нам надо будет запомнить порядок аргументов.
IDE может нам в этом помочь, но это не сильно облегчит нам жизнь.

Другая проблема будет в том, как вызвать эту функцию, если большинство параметров нам не нужны.

Можно попытаться сделать вот так:
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"]) //# undefinеd - если нам нужны параметры по умолчанию.

Выглядит нечитаемо, особенно если имеем дело с большим количеством параметров функции.

- Умные параметры функции. Решение проблемы:
Используем деструткуризацию.

Можно передать параметры как объект и функция сама деструктурирует его в переменные.

Пример:
    let options = { //# Передаём объект в функцию
    title: "My menu",
    items: ["Item1", "Item2"]
    };

    //# ...и она немедленно извлекает свойства в переменные
    function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
    //# title, items – взято из options,
    //# width, height – используются значения по умолчанию
    alert( `${title} ${width} ${height}` ); // My Menu 200 100
    alert( items ); // Item1, Item2
}
showMenu(options);

Ещё можно использовать более сложное деструктурирование с вложенными объектами:

    let options = {
    title: "My menu",
    items: ["Item1", "Item2"]
    };
  
    function showMenu({
    title = "Untitled",
    width: w = 100,  // width присваиваем в w
    height: h = 200, // height присваиваем в h
    items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
    }) {
        alert( `${title} ${w} ${h}` ); // My Menu 100 200
        alert( item1 ); // Item1
        alert( item2 ); // Item2
       }
showMenu(options);

Общий синтаксис:
    function({
    incomingProperty: varName = defaultValue
    ...
    })
Для объекта с параметрами будет создана переменная varName для свойства с именем incomingProperty по умолчанию равная defaultValue.

"Если нужны все значения по умолчанию"
В таком случае нам следует передать в функцию пустой объект. 
    showMenu({}); //# Все значения - по умолчанию
    showMenu(); //# Ошибка
Но можно сделать {} значением по умолчанию для всего объекта параметров:
    
    function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    alert( `${title} ${width} ${height}` );
    }
    showMenu(); // Menu 100 200
Весь объект аргументов по умолчанию равен {}.