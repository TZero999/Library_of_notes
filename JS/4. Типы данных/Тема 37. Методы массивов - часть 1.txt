Методов массивов крайне много. В этой главе они будут разбиты на группы.

- Добавление и удаление элементов. Splice, Slice, Concat

Мы знаем 4 способа добавления и удаления элементов:

1) arr.push(...items) – добавляет элементы в конец,
2) arr.pop() – извлекает элемент из конца,
3) arr.shift() – извлекает элемент из начала,
4) arr.unshift(...items) – добавляет элементы в начало.

Но есть и другие:

"SPLICE" - универсальный метод, умеющий добавлять, удалять и заменять элементы.

Он сильно поможет нам, например, для удаления элементов массива.

Например, если мы удалим элемент массива обычным методом delete, то выйдет следующее:
let arr = ["I", "go", "home"];
delete arr[1]; // удаляем "go"
alert( arr[1] ); // undefined
// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3

Логично. Ведь это метод для объектов. Но при удалении элемента массива нам обычно надо укоротить массив.
Поэтому мы и будем использовать splice. Его синтаксис:

arr.splice(index[, deleteCount, elem1, ..., elemN])

Разберём, что он делает пошагово:
1) Начинает работу с позиции index;
2) Удаляет N элементов инструкцией deleteCount;
3) Вставляем на место удалённых новые элементы командами elem1...elemN.

"Удаляем при помощи slice:"
Рассмотрим пример с удалением элементов при помощи slice:
et arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]

"Удаляем и заменяем элементы с помощью slice:"
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
arr.splice(0, 3, "Давай", "танцевать"); // удалить 3 первых элемента и заменить их другими
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"].

Важно знать, что можно обойтись и без удаления - deleteCount устанавливаем равным 0.
Также важно помнить, что здесь, как и во многих других методах массивов можно использовать отрицательный индекс.

"SLICE"
Этот метод возвращает НОВЫЙ массив, в который КОПИРУЕТ ЭЛЕМЕНТЫ старого, от индекса Start до индекса End.
Причём элемент START-а ВКЛЮЧАЕТСЯ вновый массив, а элемент END-a - НЕ ВКЛЮЧАЕТСЯ.
Его синтаксис:
arr.slice([start], [end])

Кстати, и Start и End могут быть ОТРИЦАТЕЛЬНЫМИ. Отсчёт, в таком случае, будет вестись с конца массива.

Это схоже со строковым методом "str.slice", но вместо подстирок возвращает подмассивы.
Вот пример:

let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3, не включая третий.)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

КСТАТИ, если использовать slice БЕЗ АРГУМЕНТОВ - мы клонируем весь массив.
Этим способом часто пользуются на практике.

"Возвращаемые arr.splice и arr.slice значения: "
А вот тут есть важная пометка, которая меня уже подводила:

SPLICE - Возвращает массив из удалённых элементов.
SLICE - Возвращает НОВЫЙ массив, в который копирует элементы со start и до end.

"CONCAT"
Метод arr.concat создаёт НОВЫЙ МАССИВ, в который КОПИРУЕТ данные ДРУГИХ МАССИВОВ и дополнительные значения.

Синтаксис:
arr.concat(arg1, arg2...)

Этот метод принимаает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
Пример использования:

let arr = [1, 2];
alert( arr.concat([3, 4]) ); // 1,2,3,4 // создать массив из: arr и [3,4]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6 // создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6 // создать массив из: arr и [3,4], потом добавить значения 5 и 6

Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
let arr = [1, 2];
let objLikeArrayarrayLike = {
  0: "что-то",
  length: 1
};
alert( arr.concat(objLikeArray) ); // 1,2,[object Object]

Но такой исход можно обойти:
Если ОБЪЕКТ имеет специальное свойство Symbol.isConcatSpreadable - он обрабатываеся, как массив.
Вот пример:

let arr = [1, 2];
let objLikeArray = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};
alert( arr.concat(objLikeArray) ); // 1,2,что-то,ещё

- Перебор: forEach
Метод arr.forEach может запускать функцию для каждого элемента массива.

Синтаксис:
arr.forEach(function(item, index, array) {
    // ... Функция для работы с item
});

Пример использования:
["Bilbo", "Gandalf", "Nazgul"].forEach(alert); // По очереди вызовет алерт с каждым из имён.

А этот пример ещё и расскажет о позиции каждого элемента в массиве:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
    alert(`${item} имеет позицию ${index} в ${array}`);
});

РЕЗУЛЬТАТ ФУНКЦИИ (если она что-то возвращает) ОТБРАСЫВАЕТСЯ И ИГНОРИРУЕТСЯ.

- Поиск в массиве

"indexOf/lastIndexOf и includes"
Данные методы имеют одинаковый синтаксис, да и делают почти одно и то же, что и их стрококвые аналоги.

1) arr.indexOf(item, from) - ищет item, НАЧИНАЯ С ИНДЕКСА from, и ВОЗВРАЩАЕТ ИНДЕКС, на котором был найден искомый элемент, В ПРОТИВНОМ СЛУЧАЕ -1.
2) arr.lastIndexOf(item, from) – ТО ЖЕ САМОЕ, но ищет СПРАВА НАЛЕВО.
3) arr.includes(item, from) – ищет item, НАЧИНАЯ С ИНДЕКСА from, И ВОЗВРАЩАЕТ TRUE, если поиск успешен.

Пример:
let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true

К слову, методы использую СТРОГОЕ сравнение (===).
Поэтому если мы ищем false -он находит конкретно false, а не 0.

"Как и когда использовать? "
Нужно знать только о наличии/ отсутствии элемента?
Тогда "arr.includes".
К тому же, у "includes" есть ещё одно незначительное, но положительное отличие:
Он правильно обрабатывает NaN:

const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)

"find и findIndex"
arr.find. - находит объект с определённым условием.

Синтаксис:
let result = arr.find(function(item, index, array) {
... });

Функция вызывается по очереди для каждого элемента массива:
1) item – очередной элемент.
2) index – его индекс.
3) array – сам массив.

ЛОГИКА: Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
  ];
let user = users.find(item => item.id == 1);
alert(user.name); // Вася

В реальности массивы, состоящие из объектов - это частое явление.
Поэтому "find" очень полезен.

Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1, с одним аргументом.
Это типично, дополнительные аргументы этой функции используются редко.

Метод "arr.findIndex" – по сути, то же самое, но возвращает индекс, на котором был найден элемент.
Если ничего не найдено - возвращает -1.

"filter"

Метод find ищет только один (первый попавшийся) элемент.
Потом функция-колбэк вернёт true.

А вот если найденных элементов может быть много - предусмотрен метод "arr.filter(fn)".

Синтаксис метода "filter" схож с find, но возвращает МАССИВ из всех подходящих элементов:
let results = arr.filter(function(item, index, array) {
});

По итогу: если true - элемент добавляется к результату, перебор продолжается.
Если ничего не найдено - возвращается пустой массив.

Пример:
let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
  ];
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
alert(someUsers); // [ { id: 1, name: 'Вася' }, { id: 2, name: 'Петя' } ]