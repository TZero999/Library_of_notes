- Преобразование массива
Методы преобразования и упрорядочения массивов:

"map"
Метод arr.map является одним из наиболее полезных и используемых.

Он вызывает функцию для каждого элемента массива и ВОЗВРАЩАЕТ МАССИВ РЕЗУЛЬТАТОВ ВЫПОЛНЕНИЯ ЭТОЙ ФУНКЦИИ.
Синтаксис выглядит так:

let result = arr.map(function(item, index, array) { 
...});

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // [ 5, 7, 6 ] - получаем МАССИВ с длиной каждого элемента массива.

"sort(fn)"
Вызов arr.sort() сортирует массив на месте, МЕНЯЯ В НЁМ ПОРЯДОК ЭЛЕМЕНТОВ.

Вообще, этот вызов возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, т.к. МЕНЯЕТСЯ И САМ МАССИВ arr.
Пример:

let arr = [ 1, 2, 15 ];
arr.sort(); // метод сортирует содержимое arr
alert( arr );  // 1, 15, 2 - оп-па. Порядок нарушен.

Всё потому, что sort() ПО УМОЛЧАНИЮ сортирует элементы массива КАК СТРОКИ!
Поэтому 15 стало < чем 2.

Чтобы использовать НАШ СОБСТВЕННЫЙ ПОРЯДОК сортировки, нам нужно ПРЕДОСТАВИТЬ ФУНКЦИЮ В КАЧЕСТВЕ АРГУМЕНТА arr.sort()

"САМЫЙ ВАЖНЫЙ ПРИМЕР для сортировки чисел с помощью sort":
Отсортировать числа по убыванию или возрастанию можно простой стрелочной функцией:

arr.sort((a, b) => a - b); - для сортировки ПО возрастанию
и
arr.sort((a, b) => b - a); - для сортировки ПО УБЫВАНИЮ.
"----------------------------------------------------------"

Пример функции для сортировки по возрастанию:

function compare(a, b) {
    if (a > b) return 1; // если первое значение больше второго
    if (a == b) return 0; // если равны
    if (a < b) return -1; // если первое значение меньше второго
}

И теперь снова попробуем отсортировать массив чисел:
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}
let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15

Почему надо писать отдельную функцию сортировки?
Массив arr может быть массивом чего угодно: содержать числа, строки, объекты или что-то ещё.
У нас есть набор каких-то неизвестных элементов.
В итоге, нам нужна функция, определяющая порядок, которая знает, по каким правилам сравнивать элементы.

Кстати, если мы захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
    alert( a + " <> " + b );
    return a - b;
});

В процессе работы алгоритм сравнивает элемент со множеством других, но он старается сделать как можно меньше сравнений.

КСТАТИ:

1) На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».
Это позволяет писать более короткие функции:

let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15

2) Лучше использовать стрелочные функции.
Но ЛУЧШЕ только для читабельности кода.
arr.sort( (a, b) => a - b );

3) Всешда используйте localeCompare для строк.
Как мы уже знаем, алгоритм сравнения строк сравниваеи буквы по их кодам в Unicode-16.
Для правильной сортировки букв многих алфавитов лучше использовать метод str.localeCompare.

let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)
alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

"reverse"
Метод arr.reverse меняет порядок элементов в arr на обратный.
Пример:

let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1

Кстати, он также возвращает массив arr с изменённым порядком элементов.

"split"
Предположим, нам надо организовать массовую рассылку сообщений.
В таком случае нам будет проще работать с массивом имён, чем с одной строкой.

Метод str.split(delim) именно это и делает. Он разбивает строку на массив ПО ЗАДАННОМУ РАЗДЕЛИТЕЛЮ DELIM.
Пример:

let names = 'Вася, Петя, Маша';
let arr = names.split(', ');
for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася, Сообщение получат: Петя, Сообщение получат: Маша.
}

У метода split есть НЕОБЯЗАТЕЛЬНЫЙ ВТОРОЙ ЧИСЛОВОЙ АРГУМЕНТ.
Это – ограничение на количество элементов в массиве.
На практике он используется довольно редко.

КСТАТИ, пустой split разобъёт строку на ОДИН массив ВСЕХ букв:
let str = "тест";
alert( str.split('') ); // [ 'т', 'е', 'с', 'т' ]

"join"
arr.join(glue) делает противоположное split действие:
Он СОЗДАЁТ СТРОКУ из элементов массива и ВСТАВЛЯЕТ разделитель glue между ними:

let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша

"reduce/ reduceRight"
Если нам нужно перебрать массив – мы можем использовать "forEach", "for" или "for..of".
Если надо перебрать массив и вернуть данные каждого элемента - используем "map".

А вот методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.
Они нужны для вычисления ЕДИНОГО ЗНАЧЕНИЯ на основе всего массива.

Синтаксис:
let value = arr.reduce(function(accumulator, item, index, array) {
// ...
}, [initial]);

Функция применяется по очереди ко всем элементам и "ПЕРЕНОСИТ" результат на следующий вызов.

АРГУМЕНТЫ методов "reduce/ reduceRight":
1) accumulator -  результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial)
2) item – очередной элемент массива,
3)index – его индекс,
4) array – сам массив.

При вызове функции РЕЗУЛЬТАТ ЕЁ ВЫЗОВА НА ПРЕДЫДУЩЕМ ЭЛЕМЕНТЕ МАССИВА ПЕРЕДАЁТСЯ КАК ПЕРВЫЙ АРГУМЕНТ!!!

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем».
Он аккумулирует результат предыдущих вызовов функции. По окончании он становится результатом всего метода reduce.

Пример:
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

Здесь используем распространённый способ вызова reduce с двумя аргументами.
Разберём логику работы reduce пошагово:

1) При первом запуске sum равен initial (последний аргумент reduce), то есть 0, в нашем случае.
current – первый элемент массива, равен 1. Таким образом, результат функции равен 1.
2) При втором запуске sum = 1, и к нему мы добавляем второй элемент массива (2).
3) При третьем запуске sum = 3, к нему добавляется следующий элемент и т.д.

Кстати, если бы мы не передали 0 в качестве [Initial] - в нашем случае ничего не изменилось бы.
Это потому, что при отсутствии initial в качестве первого значения БЕРЁТСЯ ПЕРВЫЙ ЭЛЕМЕНТ МАССИВА, и тогда ПЕРЕБОР СТАРТУЕТ УЖЕ СО ВТОРОГО.

ВАЖНО!
Использование reduce без [Initial] требует крайней осторожности.
Если массив пуст - вызов reduce без начального значения выдаст ошибку "TypeError: Reduce of empty array with no initial value".

Метод "arr.reduceRight" работает АНАЛОГИЧНО, но ПРОХОДИТ ПО МАССИВУ СПРАВА НАЛЕВО.

- Array.isArray

Массивы, как мы помним, образованы на основании объектов.
А поэтому typeof не может отличить простой объект от массива:
alert(typeof {}); // object
alert(typeof []); // object

Но из-за постоянного использования массивов придумали специальный метод:
Array.isArray(). Если внутри скобок массив - возвращает нам true.
Если же тип переменной в скобках - что угодно, но не массив - возвращает false.

Вот пример:
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true