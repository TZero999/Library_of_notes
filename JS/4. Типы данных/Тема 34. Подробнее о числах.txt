В современном JS, как мы знаем, есть два типа числе:
1) Number - обычные числа - хранятся в 64-битном формате IEEE-754 (числа с плавающей точкой двойной точности).
2) BigInt числа - дают возможность работать с числами произвольной длины. Они нужны крайне редко
и используются, когда необходимо работать со значениями > ((2^53)-1). 

- Способы записи чисел

Буква e используется для того, чтобы укоротить числа. Например:

let bil1 = 1000000000;
let bil2 = 1e9;
alert (bil1==bil2); // true.

Числа меньше нуля записываются с отрицательным значением e:

let ms1 = 0.000001;
let ms2 = 1e-6; // шесть нулей, слева от 1
alert (ms1==ms2); // true.

- Шестнадцатиричные, двоичные и восьмеричные числа

Шестнадцатиричные числа широко используются в JS для представления цветов, коддировки символов и многого другого.
Есть коротки стиль записи 0x, после которого указывается число.
Пример:

alert( 0xff ); // 255
alert( 0xFF ); // 255

Не так часто используются лвоичные и восьмеричные числа, но они тоже встречаются.
Чтобы их записать используем следующие символы перед числом:
0b - для двоичных.
0o - для восьмеричных.
Пример:

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert( a == b ); // true, с двух сторон число 255

JS официально поддерживает только 3 системы счисления. Для других систем счисления будем использовать функцию parseInt.

- toString(base)

Метод num.toString(base) возвращает СТРОКОВОЕ представление числа num в системе счисления base.
Вот примеры:

let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

base варьируется в диапазоне чисел от 2 до 36. По умолчанию base всегда 10.

base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

base=36 — максимальное основание, цифры могут быть 0..9 или A..Z.
То есть, используется весь латинский алфавит для представления числа.
Можно использовать 36-разрядную систему счисления для получения короткого представления большого числа.
К примеру, для создания короткой ссылки: alert( 123456..toString(36) ); // 2n9c

ДВЕ ТОЧКИ!

Две точки в 123456..toString(36) - не опечатка. 
Если мы поставим одну точку: 123456.toString(36), - это будет ошибкой, JS будет ожидать десятичную часть числа.
После двух точек JS понимает, что десятичная часть равна 0. Ещё можно записать и так: (123456).toString(36).

- Округление до целых чисел

В работе с числами часто приходится использовать округление.
В JS есть несколько встроенных функций для работы с округлением:

1) Math.floor - округление в меньшую сторону:  3.1 становится 3, а -1.1 — -2.
2) Math.ceil - округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
3) Math.round - округление до ближайшего числа: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
4) Math.trunc (не поддерживается в браузере IE) - удаление дробной части:  3.1 становится 3, а -1.1 — -1.

- Округление до n знаков после запятой

Здесь у нас 2 варианта действий:

1) Умножаем и делим:
Например, чтобы округлить число до второго знака после запятой, умножаем его на 100, вызываем функцию округления и делим обратно на 100.
Пример:

let num = 1.23456;
alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

2) Способ попроще, но со своим маленьким минусом - toFixed(n).
Этот метод округляет число до n знаков после запятой и возвращает СТРОКОВОЕ представление результата.
Пример:

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

Округляет он их аналогично методу Math.round - до большего числа (12.36 = 12.4).
Результат toFixed - СТРОКА!

Преобразовать результат в число можно используя унарный плюс или Number.
Вот так: +num.toFixed(5).

- Неточные вычисления. Потеря точности.

Как уже говорилось, внутри JS числа представлены в формате IEEE-754. 
Для хранения числа используется 64 бита: 52 для хранения цифр, 11 для хранения положения точки и 1 бит для хранения знака.

Если число слишком большое - оно переполняет хранилище ,JS возвращает Infinity - бесконечность:
alert( 1e500 ); // Infinity

Частая проблема JS - потеря точности. Вот пример этой проблемы:
alert( 0.1 + 0.2 == 0.3 ); // false

А чему тогда равна их сумма?
alert( 0.1 + 0.2 ); // 0.30000000000000004

В чём причина?
Число хранится в бинарной форме, как последовательность бит. Дроби 0,1 и 0,2 выглядят просто в десятичной системе, но не в двоичной,
где они являются бесконечной дробью.
JS не обладает способом хранить точные значения 0.1 или 0.2

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа.
Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует:
alert( 0.1.toFixed(20) ); // 0.10000000000000000555

Суммируя 2 числа мы суммируем их неточности. Поэтому в JS 0.1 + 0.2 – это не совсем 0.3.

К СЛОВУ, не только в JS. Такая проблема присутствует и в PHP, Java, C, Perl, Ruby - везде, где используется IEEE 754.

- Решение проблемы неточных вычислений

Обойти проблему можно и наиболее надёжный способ - округлить результат методом toFixed(n):

let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30

Но надо помнить, что toFixed всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр.
Это удобно лоя форматирования цен в интернет-магазинах (0.30$). В других случаях надо использовать унарный +:

let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3 - обратите внимание, нули отбросились.

Можно было бы воспользоваться трюком с умножением и делением на 100, но погрешность может сохраниться и проявиться в результате:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

- Ещё один пример с неточностью:
alert( 9999999999999999 ); // вернёт 10000000000000000

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит.
Остальные 11 бит хранят позицию десятичной точки и один бит – знак.
Если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше.

- Два нуля

Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.

Это происходит из-за того, что знак представлен отдельным битом, так что любое число может быть положительным и отрицательным.
И 0 не исключение. В большинстве случаев это незаметно, т.к. в JS операторы восппринимают их одинаково.
К слову - технически это разные значения, НО alert( 0 === -0) возвращает true.

- Проверки isFinite и isNaN

Числовые значения Infinity и NaN принадлежат типу number, но не являются "обычными числами".
Поэтому существуют функции для их проверки:

1) isNaN(value) - преобразует значение в число и проверяет является ли оно NaN.
Пример:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

По идее можно было бы обойтись без этой функции и использовать строгое сравнение с Nan, НО:
alert( NaN === NaN ); // false

Значение NaN уникально, оно не является равным даже самому себе.

2) isFinite(value) - преобразует аргумент в число и возвращает true, если это обычное число, т.е. не NaN/Infinity/-Infinity.
Пример:

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

- Трюк с isFinite
Иногда isFinite используется для проверки, содержится ли в строке число:

let num = +prompt("Enter a number", '');
alert( isFinite(num) ); // вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число.

При этом стоит помнить, что пустая строка интерпретируется как 0!!! И isFinite с ней всегда вернёт 0.

- Number.isNaN

Эти методы - более "строгие" версии isNaN и isFinite.
Они не преобразуют аргумент в число, а первым делом проверяют, является ли этот аргумент числом (тип number).

Number.isNaN(value) возвращает true только в том случае, если аргумент ПРИНАДЛЕЖИТ К ТИПУ NUMBER и ЯВЛЯЕТСЯ NaN.
Во всех остальных случаях возвращает false.
Примеры:

alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true
alert( Number.isNaN("str") ); // false, ведь "str" - не число
alert( isNaN("str") ); // true, т.к. isNaN сначала преобразует строку "str" и получит NaN

Т.О.:
Number.isNaN(value) - true, если это тип Number и NaN.
isNaN(value) - true, если это просто NaN любого типа.

- Number.isFinite

Number.isFinite(value) возвращает true только в том случае, когда аргумент ПРИНАДЛЕЖИТ К ТИПУ NUMBER и НЕ ЯВЛЯЕТСЯ NaN/Infinity/-Infinity.
Во всех остальных случаях возвращает false.

alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); //false
alert( Number.isFinite(2 / 0) ); // false
alert( Number.isFinite("123") ); // false, так как "123" является строкой, а не числом
alert( isFinite("123") ); // true, так как isFinite сначала преобразует строку "123" в число 123

Т.О.:
Number.isFinite(value) - true, если это тип Number и не NaN/Infinity/-Infinity.
isFinite(value) - true, если это просто не NaN/Infinity/-Infinity.

НЕ СТОИТ считать какой-то из методов более ПРАВИЛЬНЫМ. Это ДОПОЛНЯЮЩИЕ ДРУГ ДРУГА ИНСТРУМЕНТЫ!

- Object.is

Специальный метод, сравнивающий значения примерно как "===", но более надёжный.
Он надежнее т.к.:

1) Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
2) Object.is(0, -0) === false, т.к. это технически разные значения, как и говорилось выше.

НО во всех других случаях Object.is(a,b) идентичен простому строгому равенсту "a===b".

Этот способ ЧАСТО используется в спецификации JS, т.к. когда внутреннему алгоритму надо сравнить 2 объекта на 
предмет точного совпадения - он использует Object.is

- parseInt и parseFloat

Использование унарного плюса и Number() не всегда подходят для преобразования к числу.
Ведь часто с числом сожет стоять символ или символы, рзначающие единицу измерения.
Например 19€, 100px, 25см. А вдруг нам надо получить из этих строк числовое значение?

Вот тут и нужен parseInt и parseFloat.
Они "парсят" (читают) число из строки. Если в процессе чтения происходит ошибка - возвращается полученное до ошибки число.
Отличия этих двух функций: "parseInt" возвращает ЦЕЛОЕ число, "parseFloat" - С ПЛАВАЮЩЕЙ ТОЧКОЙ:
Примеры:

alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12 - только целая часть
alert( parseFloat('12.3.4') ); // 12.3 - остановка чтения на второй точке

Если эти функции не смогут прочитать ни одной цифры - вернут NaN.
Т.О.: alert( parseInt('a123') ); // NaN, т.к. первый же символ - не число.

- Второй аргумент ParseInt

Функция parseInt() имеет необязательный второй параметр.
Он определяет систему счисления, т.о. parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, Работает и без 0x
alert( parseInt('2n9c', 36) ); // 123456

- Другие математические функции

В JavaScript встроен объект Math, который содержит различные математические функции и константы.
Несколько примеров:

Math.random() - возвращает любое псевдослучайное число в ДИАПАЗОНЕ ОТ 0 ДО 1:
alert( Math.random() ); // 0.1234567894322

Math.max(a, b, c...) / Math.min(a, b, c...) - возвращает наибольшее/ наименьшее число из аргументов:
alert( Math.max(3, 5, -10, 0, 1) ); // 5

Math.pow(n, power) - возвращает число n, возведённое в степень power%
alert( Math.pow(2, 10) ); // 1024

- ИТОГО

1) Чтобы писать числа с большим количеством нулей:
Лучше использовать форму записи чисел – "e", с указанным количеством нулей.
Пример: 123e6 это 123 с 6-ю нулями 123000000.

Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. 
Пример: 123e-6 это 0.000123 (123 миллионных).

2) Для других систем счисления:

JS позволяет записывать числа сразу в:
шестнадцатеричной (0x)
восьмеричной (0o)
бинарной (0b) СС.

ParseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.

3) num.toString(base) представляет число в строковом виде в указанной системе счисления base.

4) Для проверки на NaN и Infinity:
isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN

Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN

isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity

Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не является NaN/Infinity/-Infinity

5) Для преобразования значений типа 12pt и 100px в число:
Используем parseInt/parseFloat для «мягкого» преобразования строки в число.
Данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.

6) Для дробей:
Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
Помните, что при работе с дробями происходит ПОТЕРЯ ТОЧНОСТИ.

