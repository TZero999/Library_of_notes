- new Array()

Создать массив можно и таким способом:
let arr = new Array("Яблоко", "Груша", "и тд");

Его применяют редко - он громоздкий.
Но у него есть одно преимущество - можно создать массив с заданной длиной, но с пустыми элементами:
Вот так:

let arr = new Array(2); // 
alert( arr[0] ); // undefined - нет элемента с индексом 0.
alert( arr ); // вернёт "[ <2 empty items> ]"
alert( arr.length ); // length 2

- Многомерные массивы
Массивы могут содержать "вложенные" массивы.
То бишь, кроме одномерных массивов, мы можем создавать и многомерные массивы, без каких-либо дополнительных сложностей:

Вот пример хранения матрицы:
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
  ];
alert( matrix[1][1] ); // Возвращает 5

- toString
Массивы по-своему реализуют метод toString:

let arr = [1, 2, 3];
alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

А теперь ещё пример:
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"

Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString.
И реализуют его таким образом, что [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".
Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку.

- НЕ стоит СРАВНИВАТЬ массивы при помощи ==

В JavaScript не следует сравнивать при помощи оператора ==, как в некоторых других ООП.

У этого оператора нет специального подхода к массивам и он работает с ними, как и с любыми другими объектами.

Вспомним как в JS сравниваются объекты:
1) Два объекта равны друг другу == если они ссылаются на один и тот же объект.
2) Если один из аргументов == является объектом, а другой – примитивом, то происходит преобразование (см. Тему 32. Преобразование объектов в примитивы)
3) …За исключением null и undefined, которые равны == друг другу и ничему больше.
Оператор строгого равенства === ещё проще, так как он не преобразует типы.

Что это всё значит?
А то, что если мы сравниваем массивы с помощью == они никогда не будут одинаковыми.
Вернее будут только когда мы сравним две переменные, которые ссылаются на один и тот же массив.

Пример:
alert( [] == [] ); // false
alert( [0] == [0] ); // false

Здесь массивы - разные объекты. Поэтому они не равны.
А оператор == не выполняет сравнения по элементам.

Да и при сравнении с примитивами можно получить странные на первый взгляд результаты:
alert( 0 == [] ); // true
alert('0' == [] ); // false

Но если вспомнить о преобразовании то всё становится ясно: Массив преобразуется в примитив и становится " " - пустой строкой.
При сравнении с нулём пустая строка преобразуется к числу, получае 0 == 0.
При сравнении со строкой - строка " " и строка "0" - разные строки. Логично, что они не равны.

- Как правильно сравнить массивы?
Не используйте оператор ==!
Вместо этого сравните их по элементам в цикле.
Либо же используйте методы итерации (описанны в следующей теме).