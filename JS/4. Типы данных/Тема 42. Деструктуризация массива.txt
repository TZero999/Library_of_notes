- Деструктуризация массива

Пример:
    let arr = ["Ilya", "Kantor"]
    let [firstName, surname] = arr; //# Записываем firstName = arr[0], surname = arr[1]

    alert(firstName); // Ilya
alert(surname);  // Kantor

Это и есть деструктурирующее присваивание.
Теперь мы можем использовать переменные вместо элементов массива.

Такие переменные отлично выглядят в сочетании со split и другими методами, возвращающими массив:
    let [firstName, surname] = "Ilya Kantor".split(' ');
    alert(firstName); // Ilya
alert(surname);  // Kantor

"Деструктуризация != Разрушение"
Деструктурирующее присваивание не уничтожает массив.
Оно вовсе ничего не делает с правой частью присваивания.
Его задача - скопировать нужные значения в переменные.

"Пропуск ненужных элементов с помощью запятых"
let [firstName, , , title] = ["Gaius", "Julius", "Ceasar", "Consul", "of the Roman Republic"]
alert( title ); // Consul

"Деструктуризация аботает с любым перебираемым объектом справа"
let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);

"Присваивается чему угодно с левой стороны"
    let user = {};
    [user.name, user.surname] = "Ilya Kantor".split(' ');
    //# [user.name, user.surname] = ["Ilya", "Kantor"]; - можно и так.
    alert(user.name); // Ilya
alert(user.surname); // Kantor

"Цикл с .entries()"
Метод Object.entries(obj) можно использовать с деструктуризацией.
Это позволит проще перебирать ключи и значения объекта.
    let user = {
    name: "John",
    age: 30
    };
  
    for (let [key, value] of Object.entries(user)) { //# цикл по ключам и значениям
        alert(`${key}:${value}`); //# name:John, затем age:30
}

То же самое для Map:
    let user = new Map();
    user.set("name", "John");
    user.set("age", "30");

    // Map перебирает как пары [ключ, значение], что очень удобно для деструктурирования
    for (let [key, value] of user) {
alert(`${key}:${value}`); // name:John, затем age:30

"Обмен переменных"
Есть трюк для обмена значений двух переменных с использованием деструктурирующего присваивания:
    let guest = "Jane";
    let admin = "Pete";

    [guest, admin] = [admin, guest]; //# Меняем местами значения. Теперь guest = "Pete", admin = "Jane"
    alert(`${guest} ${admin}`); // Pete Jane (успешно заменено!)

Здесь мы создали временный массив из двух переменных и сразу деструктурируем его в порядке замены.
Т.О. можно менять местами куда больше, чем 2 переменные.

"Остаточные параметры <...>"

Обычно, если массив длиннее, чем список слева - лишние элементы опускаются.
Но если нам надо сохранить остаточные элементы - можно использовать оператор "троеточие":

Пример:
    let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
    alert(rest[0]); // Consul
    alert(rest[1]); // of the Roman Republic
    alert(rest); // [ 'Consul', 'of the Roman Republic' ]
//# rest - это массив элементов, начиная с 3-го

Необходимо соблюдать синтаксис: Троеточие должно рсполагаться перед именем переменной: ...rest, ...any, ...other.

"Значения по умолчанию"
Значений в массиве может быть и меньше, чем в присваивании. Ошибки не будет.
Отсутствующие значения будут неопределены (undefined).

Для таких ситуаций можно указать "значение по умолчанию".
Оно заменит отсутствующие значения.
Значение по умолчанию указывается при помощи "="

Примём значениями по умолчанию могут быть даже функции.
Они будут выполняться при условии отсутствия значений.

Пример:
    // prompt запустится только для surname
    let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
    alert(name); //# У нас запросят Surname, а затем алерт выдаст Julius (из массива)
alert(surname); //# а здесь алерт выдаст то, что мы ввели в запросе Surname-а.

