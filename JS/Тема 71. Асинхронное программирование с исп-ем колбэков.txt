Есть код, загружающий на страницу сторонний скрипт:

function loadScript(src) {
    let script = document.createElement('script');
    script.src = src;
    document.head.append(script);
}

Многие действия в JS асинхронны - они не дожидаются завершения предыдущей команды.

Если в случае первой записи мы попытаемся сразу же использовать результат загруженного скрипта
есть все основания полагать, что мы получим ошибку:
    {
    loadScript('/my/script.js'); # Пускай в скрипте есть "function newFunction() {…}"
    newFunction(); # Ошибка, такой функции не существует!
    }

Это происходит из-за того, что newFunction() не дожидается 
выполнения загрузки и выполнения предыдущего скрипта.

Поэтомы мы добавляем в качестве второго аргумента функцию "callback" и 
вызываем эту функцию прямо во время скрипта с помощью команды onload.

 function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script); #Новая строка, запускающая скрипт сразу же по готовности.
    document.head.append(script);
}

Однако этого недостаточно. Чтобы всё сработало необходимо вызывать новую функцию (использующую
результаты предыдущей) в коллбэке: {
    loadScript('/my/script.js', function() {
    # Эта функция вызовется после того, как загрузится скрипт
    newFunction(); // теперь всё работает
    ...
  })};

# Отслеживание ошибок:
Лучше продумать возможность возникновения ошибки при загрузке скрипта:
    function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
  
    script.onload = () => callback(null, script);
    script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));
  
    document.head.append(script);
  }

  В случае успешной загрузки мы вызовем callback(script), а в случае неудачи - callback(error).
  Этот подход называют "Колбэк с первым аргументом - ошибкой".

  Получается, что первый аргумент у функции колбэка предназначен для действий при ошибке - callback(error);
  Второй и последующие аргументы для отображения результатов - callback(null, result1, result2).

  Итог - одна и та же функция используется и для вывода результатов, и для обработки ошибки.

# Пирамида вызовов
  Что если один колбэк вызывает другой колбэк, а тот, в свою очередь, вызывает следующий...?
  Теоретически можно просто сделать "пирамиду":
  Например, сначала мы загружаем скрипт 1.js.
  Если нет ошибки - загружаем скрипт 2.js.
  Если всё в порядке - загружаем третий скрипт 3.js и т.д.

  Чем больше вложенных колбэков - тем сложнее поддерживать и контролировать код,
  растущий вправо с каждым вложенным вызовом.

  Такой подход не приветствуется.
  Можно попытаться разбить код на отдельные функции, но это не лучшее решение - код будет
  тяжело читаться из-за необходимости каждый раз пробегаться глазами по разным кускам кода.

  Лучший способ организовать такую вложенность - Promise-ы.

  