JavaScript - язык с сильным функционально-ориентированным уклоном.
Он даёт нам много свободы.

Функция может быть:
1) динамически создана;
2) скопирована в другую переменную;
3) передана как аргумент другой функции.

Нам известно, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется часто.

Но что произойдёт, если внешние переменные изменятся?
Функция получит последнее значение или то, которое существовало на момент создания функции?

Что произойдёт, когда функция переместится в другое место в коде и будет вызвана уже оттуда?
Она получит доступ к внешним переменным своего нового местоположения?

Разные языки в таких ситуациях ведут себя по-разному.

- 2 главных вопроса темы:
Рассмотрим 2 ситуации, а зачем изучим внутренние механизмы шаг за шагом.

1) Функция sayHi использует внешнюю переменную name. Какое имя будет в алерте следующего кода?
    let name = "John";
    function sayHi() {
    alert("Hi, " + name);
}
name = "Pete";
sayHi(); //# что будет показано: "John" или "Pete"?

Это - частая ситуация в браузерной и серверной разработке.
Выполнение функции может быть запланировано куда позже, чем её создание.

2) Функция makeWorker создаёт другую функцию и возвращает её. Новая функция может быть вызвана откуда-то ещё.
Она получит доступ к внешним переменным из места своего создания или места выполнения? Или из обоих мест?

function makeWorker() {
    let name = "Pete";
    return function() {
    alert(name);
    };
  }

  let name = "John";
  let work = makeWorker(); //# create a function

work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)

- Лексическое окружение. Что такое переменная?

В JS у каждой выполняемой функции, блока кода и самого скрипта есть связанный с ними внутренний (скрытый) объект - "Лексическое окружение"

Этот объект - LexicalEnvironment - состоит из двух частей:
1) EnvironmentRecord - объект, в котором хранятся локальные переменные (а ещё this и др.)
2) Ссылка на "внешнее лексическое окружение" - ссылка на код, находящийся снаружи фигурных скобок.

Переменная - это СВОЙСТВО специального внутреннего объекта - "EnvironmentRecord".
"Получить/ изменить переменную" = "Получить/ изменить свойство объекта EnvironmentRecord".

В коде "let phrase = 'Hello'" только одно лексическое окружение, внешнего окружения нет.
Это - глобальное лексическое окружение, связанное со всем скриптом.

А вот если мы напишем так:
  let phrase;
  phrase = 'Hello';
phrase = 'Bye';

Здесь обсуждение хода работы лексического окружения лучше разделить на 4 части:
1) В начале скрипта лексическое окружение пустое;
2) Появляется определение переменной phrase. Значение не присвоено, поэтому оно undefined;
3) Переменной phrase присваивается значение 'Hello';
4) Переменная phrase меняет значение на 'Bye'.

Итог:
* "Переменная" - всего-навсего свойство специального внутреннего объекта, связанного текущим блоком/ функцией/ скриптом.
* Работа с переменными - это работа со свойствами объекта.

- Function Declaration
Переменные объявляются через let. Функции же полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
Для верхнеуровневых функций это означает момент, когда сам скрипт начинает выполнение.

Поэтому мы можем вызвать функцию, объявленную через "Function Declaration" до того, как она определена.

Выходит, что при наличии "Function Declaration", в момент запуска скрипта в лексическом окружении уже что-то есть.
Так, если есть функция "say2" и переменная "phrase", то в логического окружении на старте скрипта сразу есть запись "say: function",
а затем в нём появляется запись "phrase: 'Hello'" (после объявления переменной).

- Внутреннее и внешнее лексическое окружение
Итак, есть код:
  let phrase = 'Hello';
  function say(name) {
    alert( `${phrase}, ${name}!` );
  }
say ('John'); //# Hello, John!

В течение вызова say() использует внешнюю переемнную "phrase".

При запуске функции для неё создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.

Итак, при выполнении кода на строке "alert" у нас есть уже ДВА ЛЕКСИЧЕСКИХ ОКРУЖЕНИЯ: внутреннее (для вызываемой функции) и внешнее (глобальное).
* Внутреннее лексическое окружение соответсвует выполнению функции say.
  В нём находится переменная name. Мы вызываем say('John'), а значит значение переменной name = "John".
* Внешнее лексическое окружение - глобальное лексическое окружение.
  В нём находится уже вызванная переменная "phrase" и сама функция "say: function".
У внутреннего окружения есть ссылка на внешнее - "outer".

- ВАЖНО
Когда код хочет получить доступ к перееменной - сначала происходит поиск по внутреннему лексическому окружению.
Затем - по внешнему. Таким образом поиск происходит по всем окружениям до глобального.
ПЕРЕМЕННОЙ НЕТ?
В strict mode получим ошибку. 
Без strict mode присваивание несуществующей переменной создаст новую глобальную переменную с таким именем.

Посмотрим, как поиск происходит на примере:
Alert внутри say пытается получить доступ к name. Эта переменная есть в лексическом окружении функции.
Когда alert попытается получить доступ к phrase он последует по ссылке на внешнее логическое окружение и найдёт переменную там.

- Ответ на первый вопрос: Pete.
Теперь у нас есть ответ на первый вопрос:
ФУНКЦИЯ получаеи ТЕКУЩЕЕ значение ВНЕШНИХ переменных, то бишь их последнее значение.

Старые значения переменных нигде не сохраняются. 
Когда функция хочет получить доступ к переменной - она берёт её текущее значение из своего внутреннего или внешнего лексического окружения.

- Один вызов = одно лексическое окружение.
Новое лексическое окружение создаётся каждый раз, когда выполняется функция.
Если функция вызывается несколько раз - для каждого вызова создаётся новое окружение со своими перменными и параметрами.

- Лексическое окружение - специальный внутренний объект.
"Лексическое окружение" - специальный внутренний объект.
Мы не можем получить к нему доступ из кода и менять его напрямую.
Сам движок JS может его оптимизировать, уничтожать и выполнять ряд других уловок, но видимое поведение объекта от этого никак не меняется.


