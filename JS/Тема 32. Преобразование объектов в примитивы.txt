Можем ли мы сложить 2 объекта? А вычесть из одного объекта другой?

JS не позволяет настраивать работу операторов с объектами.
В отличие от Ruby или C++ здесь нет специальных объектных методов для обработки сложения (или др. операторов).

В случае проведения такой операции JS преобразует объекты в примитивы,
выполняет поставленную задачу над примитивами и ВОЗВРАЩАЕТ ПРИМИТИВ!

Это важное ограничение JS: (Obj1) + (Obj2) в результате даёт ПРИМИТИВ.

ИТОГ: Результат математических действий над объектами - ВСЕГДА ПРИМИТИВ!

Т.О. мы не можем создавать объекты, складывать их с другими объектами и ожидать "суммированный" объект.
Поскольку технически здесь мало что реализуемо В РЕАЛЬНЫХ ПРОЕКТАХ НЕТ МАТЕМАТИКИ С ОБЪЕКТАМИ!

- Правила преобразования объектов в примитивы

В теме 7 "Правила преобразования типов в JS" (https://learn.javascript.ru/type-conversions) мы не затронули преобразование объектов.

Есть 3 правила преобразования объектов:

1) Объект НЕ ПРЕОБРАЗУЕТСЯ к логическому типу. В логическом контексте все объекты всегда true.

2) Числовое преобразование происходит, когда мы применяем математичсекие функции к объектам.
Так, объекты Date (будут расмотрены в главе "Дата и время" - https://learn.javascript.ru/date) могут
быть вычтены и результатом будет разница во времени между двумя датами.

3) Преобразование к строке обычно происходит, когда мы выводим на экран объект при помощи alert(obj).

Но, в случае необходимости, мы можем сами реализовать свои правила преобразования к строкам и числам.
Для этого используются специальные объектные методы.

- Хинты

Как JS решает, какое преобразование ему применить?

Есть 3 варинта преобразования типов, происходящих в различных ситуациях.
Их называют ХИНТАМИ, как описано в самой спецификации JS:

1) "string"
Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку.
Например, alert:

alert(obj); // вывод
anotherObj[obj] = 123; // используем объект в качестве ключа

2) "number"
Для преобразования объекта к числу:

let num = Number(obj);// явное преобразование

// математические преобразования (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;
let greater = user1 > user2; // сравнения больше/меньше

Большинство встроенных математических функций включают в себя такое преобразование.

3) "default"
Редкий вариант, происходит когда оператор "не уверен", какой тип ему стоит ожидать.

Например, тот же бинарный плюс (obj1 + obj2) может работать с числами (складывать их) и со строками (объединять их в одну.
Т.О. если бинарный плюс получает объект в качестве аргумента - он использует хинт "default" для преобразования объекта.

Также хинт "default" используется при сравнении с помощью === со строкой, числом или символом.

ИНТЕРЕСНЫЙ ФАКТ:
Операторы сравнения (> и <) тоже могут использоваться с числами и строками, НО по историческим причинам,
они всегда используют хинт "number".

На практике всё проще:
ВСЕ встроенные объекты (кроме Date) реализуют "default" тем же способо, что и "number".

- Очерёдность действий JS при преобразовании объекта:
1) Вызывает метод obj[Symbo.toPrimitive](hint). Смотрит, существует ли он;
2) Если хинт равен "string" - пробует вызвать obj.toString() или obj.valueOf(). Смотрит какой из них существует;
3) Иначе, если хинт "number"/"default" - пробует вызвать obj.valueOf() или obj.toString(). Смотрит, какой из них существует.

- Первый метод в списке сверху - Symbol.toPrimitive

Есть встроенный символ с именем Symbol.toPrimitive. 
Его следует использовать для обозначения метода преобразования. 
Синтаксис такой:

obj[Symbol.toPrimitive] = function(hint) { // Код для преобразования объекта в примитив. 
    // "hint" - это или "string", или "number", или "default". Возвращает код примитивное значение.
}

Если этот метод существует - он используется для всех хинтов, больше никаких методов нам не надо.
Пример:

let user = {
    name: "John",
    money: 1000,
    [Symbol.toPrimitive](hint) {
      alert(`hint: ${hint}`);
      return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
  };

alert(user); // Сначала выдаст нам "hint: string", затем {name: "John"}
alert(+user); // Сначала выдаст "hint: number", затем число 1000
alert(user + 500); // Сначала выдаст нам "hint: default", затем число 1500

Из примера видно, что объект "user" автоматически становится то строкой, то числом.
Т.О. видим, что метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования.

- Два других метода - toString/ valueOf

Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:

1) Для хинта "string" вызывается метод "toString". Если его нет или он возвращает объект, а не примитив -
вызывается "valueOf". Т.О. в строковом преобразовании toString имеет приоритет.

2) Для других хинтов вызывается "valueOf". Если его нет или он возвращает объект, а не примитив -
вызывается "toString". Т.О. в математических операциях приоритет имеет valueOf.

Методы "toString" и "valueOf" - не символы. Это древние "обычные" методы со строковыми именами.
Это старомодный способ реализации преобразования.

ЕСЛИ toString или valueOf возвращают ОБЪЕКТ - метод игнорируется.

- ДАЛЬШЕ КАКИЕ-ТО ДИКО НЕЯСНЫЕ ВЫСКАЗЫВАНИЯ. ВОЗМОЖНО В БУДУЩЕМ ЭТОТ КУСОК СТАНЕТ ПОНЯТНЕЕ:
(По умолчанию обычный объект имеет следующие методы toString и valueOf:
Метод toString возвращает строку "[object Object]". Метод valueOf возвращает сам объект.
Пример:

let user = {name: "John"};
alert(user); // [object Object]
alert(user.valueOf() === user); // true
Таким образом, если мы попытаемся использовать объект в качестве строки, как например в alert или вроде того,
то по умолчанию мы увидим [object Object].
Значение по умолчанию valueOf упоминается здесь только для полноты картины, чтобы избежать какой-либо путаницы.
Как вы можете видеть, он возвращает сам объект и поэтому игнорируется. Не спрашивайте меня почему, это по историческим причинам.
Так что мы можем предположить, что его не существует.

P.S.: Возможно тут речь идёт о том, что алерт изначально использует строковое преобразование и выводит строку [object Object],
а когда мы пытаемся использовать valueOf нам возвращается объект... Тогда, по идее, он должен проигнорироваться при вызове без строгого сравнения.
Но этого не произойдёт, т.к.
alert(user.valueOf()); // даёт нам алерт с теми же [object Object]...
Пока не совсем понятно.)
- КОНЕЦ СТРАННОГО КУСКА ИНФОРМАЦИИ

- Работа с toString и valueOf:

Применим оба метода для настройки преобразования. Вот пример с тем же объектом user:

let user = {
    name: "John",
    money: 1000,
 
    toString() {   // для хинта равного "string"
      return `{name: "${this.name}"}`;
    },
  
    valueOf() {  // для хинта равного "number" или "default"
      return this.money;
    }
};
alert(user); // Даст нам сразу {name: "John"}
alert(+user); // Сразу выдаст нам число 1000
alert(user + 500); // Выдаст нам число 1500

- Чутка тестов с отсебятиной для понимания происходящего:
После некоторых тестов в Plunker я обнаружил следующее:
1) Если в этот код добавить "свойство money : 1000" и тоже попытаться привести это к строке - получим те же алерты.
2) Добавим ещё один toString, но он будет возвращать "return this.money;". Получим уже алерты с 1000 и 1500.
ДАЖЕ если не менять первый toString.
3) Убираем первый toString - получаем алерты с 1000 и 1500.
4) Побалуемся. В последней строке кода меняем всё на alert(user-900 + '500'). Получаем алерты с 1000 и 100500.
5) Меняем оставшийся toString с "return this.money;" на "return this.name;". Получаем алерты John и NaN500
6) Дальше, чтобы привести всё в порядок и выдавать в алерте John и 100500 нам надо:
либо сделать 2 toString-а с "return this.name" и "return this.money",
либо сделать toString с "return this.name" и valueOf с "return this.money",
либо использовать метод [Symbol.toPrimitive](hint), как в примере.

Выходит, ЧТО кусок кода с toString(){return this.money}, как и говорилось до этого, не возвращает строку, а возвращает объект,
из-за чего JS сам автоматически заменяет его на valueOf()?
- Конец тестов.

- Преобразование может вернуть любой примитивный тип

Важная вещь в преобразовании примитивов в том, что методы преобразования не всегда возвращают подсказанный хинтом примитив!

НЕТ КОНТРОЛЯ над тем, вернёт ли toString именно строку, или 
способа, чтобы метод Symbol.toPrimitive возращал ИМЕННО ЧИСЛО для хинта "number".

Единственное важное условие для самой системы - эти методы ОБЯЗАНЫ возвращать примитив, а не объект.

- Историческая справка и наличие/отсутствие шибки при возврате объекта:
toString или valueOf не даёт нам ошибку, при возвращении объекта. Они просто игнорируются, будто бы их нет вовсе.
Это из-за того, что в древние времена у JS не было хорошей концепции "ошибок".
А вот метод Symbol.toPrimitive уже «четче». Если он не вернёт примитив - будет ошибка.

- Дальнейшие преобразования:

Рассматрим преобразования, происходящие по цепочке. Например, вспомним функцию умножения *, преобразующую операнды в числа.

Передадим в качестве аргумента для умножения объект. JS выполнит вычисления в 2 стадии:

1) Объект будет преобразован в примитив.
2) Если для дальнейшего вычисления нужно ещё одно преобразование - примитив будет преобразован дальше.

Пример:
let obj = {
    toString() { // toString обрабатывает все преобразования в случае отсутствия других методов
      return "2";
    }
};
alert(obj * 2); // 4! 

Было выполнено 2 операции:
1) Сначала объект был преобразован в примитив ( строка "2");
2) Затем "2" * 2 стало 2 * 2 (строка преобразуется в число).

К слову, бинарный плюс здесь отработал бы иначе: 
let obj = {
    toString() {
      return "2";
    }
};
alert(obj + 2); // 22, т.к. была возвращена строка. Это - конкатенация

- ИТОГО

Преобразование объекта в примитив вызывается автоматически многими встроенными функциями/ операторами,
которые ожидают примитив в качестве значения.

Существует всего 3 типа (Хинта) для преобразования объекта в примитив:
1) "string" (для alert и других операций, которым нужна строка)
2) "number" (для математических операций)
3) "default" (для некоторых других операторов, обычно объекты реализуют его как "number")
Спецификация JS явно описывает для каждого оператора, какой следует использовать хинт.

Алгоритм прелбразования следующий:
1) Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
2) В случае, если хинт равен "string"
происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
3) В случае, если хинт равен "number" или "default"
происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.

Все эти методы (если они определены) должны возвращать примитивы.

НА ПРАКТИКЕ обычно достаточно реализовать только obj.toString(), как универсальный метод преобразования к строке.
Он позволяет возвращать удобочитаемое представление объекта и обычно используется всё это
для логирования или отладки кода.

